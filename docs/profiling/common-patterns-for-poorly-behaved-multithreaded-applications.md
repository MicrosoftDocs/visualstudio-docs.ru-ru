---
title: Общие шаблоны для неправильно работающих многопоточных приложений
description: Визуализатор параллелизма предоставляет графики для многопоточных приложений и коллекцию шаблонов плохо работающих потоков.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- vs.cv.threads.tools.gallery
helpviewer_keywords:
- Concurrency Visualizer, common patterns for poorly-behaved multithreaded applications
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: 9fc83fd49184a0bb784b44ec80588571e8d6e560
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99941324"
---
# <a name="common-patterns-for-poorly-behaved-multithreaded-applications"></a>Общие шаблоны для неправильно работающих многопоточных приложений

Визуализатор параллелизма помогает разработчикам визуализировать поведение многопоточного приложения. В этом средстве предусмотрена коллекция общих шаблонов для нескольких многопоточных приложений с неправильным поведением. В коллекции содержатся типичные узнаваемые визуальные шаблоны, которые реализуются с помощью данного средства, а также объяснение поведения, представленного каждым шаблоном, вероятный результат такого поведения и наиболее распространенные способы его устранения.

## <a name="lock-contention-and-serialized-execution"></a>Конфликт блокировок и сериализованное выполнение

![Результирующий конфликт блокировки в сериализованном выполнении](../profiling/media/lockcontention_serialized.png "LockContention_Serialized")

Иногда распараллеленное приложение продолжает выполняться последовательно, несмотря на наличие нескольких параллельных потоков и достаточного количества логических ядер у компьютера. Первый симптом — низкая многопоточная производительность, возможно даже ниже, чем при последовательной реализации. В представлении потоков не видно параллельного выполнения нескольких потоков, вместо этого в любой момент времени выполняется только один поток. Если щелкнуть здесь сегмент синхронизации в потоке, отобразится стек вызовов, блокирующий поток (блокирующий стек вызовов), а также поток, удаляющий блокирующее условие (разблокирующий стек вызовов). Кроме того, если в анализируемом процессе возник разблокирующий стек вызовов, отобразится соединитель для потока. Далее можно переходить к коду от блокирующих и разблокирующих стеков вызова, чтобы установить причину сериализации.

Как показано на следующем рисунке, визуализатор параллелизма может также обнаруживать подобные признаки в представлении использования ЦП, когда, несмотря на наличие нескольких потоков, приложение использует только одно логическое ядро.

Дополнительные сведения см. в разделе "Запуск с помощью раздела проблем" в статье журнала MSDN Magazine [Производительность потоков — профилирование параллелизма на предмет состязания за ресурсы в Visual Studio 2010](/archive/msdn-magazine/2010/june/msdn-magazine-thread-performance-resource-contention-concurrency-profiling-in-visual-studio-2010).

![Состязание при блокировке](../profiling/media/lockcontention_2.png "LockContention_2")

## <a name="uneven-workload-distribution"></a>Неравномерное распределение рабочей нагрузки

![Снимок экрана: график рабочей нагрузки для параллельных потоков в визуализаторе параллелизма. Потоки заканчиваются в разное время, отображая ступенчатую диаграмму направленности.](../profiling/media/unevenworkload_1.png)

При неравномерном распределении рабочей нагрузки между несколькими параллельными потоками в приложении по мере завершения каждого потока образуется своеобразная лестница, как показано на изображении выше. Обычно время запуска всех параллельных потоков в визуализаторе параллелизма практически совпадает. Однако заканчиваются эти потоки обычно не одновременно, а произвольным образом. Этот шаблон показывает неравномерное распределение работы между группами параллельных потоков, что может ухудшать производительность. Лучший способ решения этой проблемы — переоценка алгоритма, по которому рабочая нагрузка распределяется между параллельными потоками.

Как показано на следующем рисунке, эти признаки могут проявляться в визуализаторе параллелизма в представлении использования ЦП в виде поэтапного снижения уровня использования центрального процессора.

![Снимок экрана: представление "Использование ЦП" в визуализаторе параллелизма, отображающее ступенчатую диаграмму направленности в конце графика "Использование ЦП".](../profiling/media/unevenworkload_2.png)

## <a name="oversubscription"></a>Превышение лимита подписки

![Снимок экрана: график рабочей нагрузки для активных потоков в визуализаторе параллелизма. В условных обозначениях отображено количество времени, затраченного на выполнение и вытеснение.](../profiling/media/oversubscription.png)

В случае превышения лимита подписки число активных потоков процесса превышает число доступных ядер системы. На предыдущем рисунке показаны результаты превышения лимита подписки с явно выраженным наличием приоритетного прерывания во всех активных потоках. Кроме того, на легенде показано, что на приоритетное прерывание затрачена значительная доля времени (84 процента в данном примере). Это может свидетельствовать о том, что количество параллельных потоков, запрашиваемых процессом в системе, превышает число логических ядер. Однако это может также свидетельствовать о том, что ресурсы, которые предположительно должны были быть доступными для данного процесса, используются в системе другими процессами.

При анализе данной проблемы нужно учитывать следующие особенности.

- Возможно, превышение лимита подписки является общесистемной проблемой. Следует учитывать, что приоритетное прерывание потоков данного процесса может также инициироваться другими процессами в системе. Если навести указатель на сегмент приоритетного прерывания в представлении потока, отобразится подсказка с указанием потока и процесса, которые инициировали такое прерывание данного потока. Инициировавший прерывание процесс не обязательно выполняется все время, в течение которого данный процесс не выполнялся вследствие приоритетного прерывания, однако эти сведения позволяют определить источник избыточных приоритетных прерываний процесса.

- Проанализируйте принцип определения процессом надлежащего числа потоков для выполнения на этом этапе работы. Если процесс непосредственно вычисляет число активных параллельных потоков, попытайтесь изменить алгоритм, усовершенствовав подсчет числа доступных в системе логических ядер. Если используется среда выполнения с параллелизмом, библиотека параллельных задач (Task Parallel Library) или PLINQ, эти библиотеки выполняют вычисление количества потоков.

## <a name="inefficient-io"></a>Неэффективный ввод-вывод

![Неэффективный ввод-вывод](../profiling/media/inefficient_io.png "Inefficient_IO")

Избыточное или недостаточное использование ввода-вывода обычно приводит к неэффективности работы приложений. Рассмотрим предыдущий рисунок. В профиле видимой временной шкалы указано, что 44 процента видимого времени выполнения приложений потрачено на ввод-вывод. На временной шкале указано много операций ввода-вывода, что свидетельствует о частом блокировании ввода-вывода в профилируемом приложении. Чтобы просмотреть подробные сведения о характере операций ввода-вывода и блокировании программы, увеличьте проблемные области, проанализируйте профиль видимой временной шкалы, а затем щелкните определенный блок ввода-вывода, чтобы просмотреть текущие стеки вызова.

## <a name="lock-convoys"></a>Колонны блокировок

![Колонны блокировок](../profiling/media/lock_convoys.png "Lock_Convoys")

Колонны блокировок возникают, когда приложение получает блокировки в порядке поступления запросов и когда скорость прибытия на блокировку превышает скорость получения блокировок. При сочетании этих двух условий блокировки начинают резервироваться. Один из способов устранения этой проблемы заключается в использовании "нечестных" блокировок или блокировок, которые предоставляют доступ первому потоку, чтобы он мог перейти в разблокированное состояние. На предыдущем рисунке показано такое построение в колонну. Для решения этой проблемы попытайтесь снизить число конфликтов при синхронизации объектов и прибегнуть к "нечестным" блокировкам.

## <a name="see-also"></a>См. также

[Представление потоков](../profiling/threads-view-parallel-performance.md)