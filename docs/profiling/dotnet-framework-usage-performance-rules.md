---
title: Правила производительности использования в .NET Framework | Документы Майкрософт
description: Общие сведения о правилах производительности в категории "Использование .NET Framework". Определение конкретных методов, которые можно оптимизировать, а также более общих шаблонов использования.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: ab573755-6370-48aa-853d-a7321c424c79
author: mikejo5000
ms.author: mikejo
manager: jmartens
monikerRange: vs-2017
ms.workload:
- multiple
ms.openlocfilehash: f8ec2756353ac56b3b5d44e2a50c4d4f5b1c7ebf
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99955389"
---
# <a name="net-framework-usage-performance-rules"></a>Правила производительности использования в .NET Framework
Правила производительности в категории "Использование .NET Framework" определяют конкретные методы, которые можно оптимизировать, а также более общие шаблоны использования, такие как сборка мусора и конфликты блокировки, которые можно расследовать для решения проблем производительности.

|Правило|Описание|
|-|-|
|[DA0001. Использование StringBuilder для объединений](../profiling/da0001-use-stringbuilder-for-concatenations.md)|Вызовы метода <xref:System.String.Concat(System.String,System.String)?displayProperty=fullName> составляют значительную часть данных профилирования. Для построения строк из нескольких сегментов рекомендуется использовать класс <xref:System.Text.StringBuilder>.|
|[DA0005. Часто используемые коллекции GC2](../profiling/da0005-frequent-gc2-collections.md)|Относительно большое число объектов памяти .NET освобождается при сборке мусора поколения 2. Если слишком много объектов с небольшим временем существования остается после сборки поколения 1, затраты на управление памятью могут оказаться слишком высокими.|
|[DA0006. Переопределение Equals() для типов значений](../profiling/da0006-override-equals-parens-for-value-types.md)|Вызовы метода `Equals` или операторов равенства открытого типа составляют значительную часть данных профилирования. Рекомендуется использовать более эффективный метод.|
|[DA0007. Избегайте использования исключений для потока управления](../profiling/da0007-avoid-using-exceptions-for-control-flow.md)|Высокая частота вызовов обработчиков исключений .NET Framework в данных профилирования. Рекомендуется использовать другую логику потока управления для уменьшения числа вызываемых исключений.|
|[DA0010. Затратный метод GetHashCode](../profiling/da0010-expensive-gethashcode.md)|Вызовы метода `GetHashCode` типа составляют значительную часть данных профилирования, или метод `GetHashCode` выделяет память. Упростите метод.|
|[DA0011. Затратный метод CompareTo](../profiling/da0011-expensive-compareto.md)|Метод `CompareTo` типа является затратным, или метод выделяет память. Упростите метод `CompareTo`.|
|[DA0012. Слишком много вызовов метода Reflection](../profiling/da0012-significant-amount-of-reflection.md)|Вызовы методов <xref:System.Reflection?displayProperty=fullName>, таких как <xref:System.Reflection.IReflect.InvokeMember%2A> и <xref:System.Reflection.IReflect.GetMember%2A>, или методов типа, таких как <xref:System.Type.InvokeMember%2A>, составляют значительную долю данных профилирования. По возможности рекомендуется заменить эти методы ранней привязкой к методам зависимых сборок.|
|[DA0013. Интенсивное использование String.Split или String.Substring](../profiling/da0013-high-usage-of-string-split-or-string-substring.md)|Вызовы методов <xref:System.String.Split%2A?displayProperty=fullName> или <xref:System.String.Substring%2A> составляют значительную часть данных профилирования. Если выполняется проверка на наличие в строке подстроки, рекомендуется использовать <xref:System.String.IndexOf%2A> или <xref:System.String.IndexOfAny%2A>.|
|[DA0018. 32-битное приложение выполняется с ограничениями управляемой памяти процесса](../profiling/da0018-32-bit-application-running-at-process-managed-memory-limits.md)|Системные данные, собранные во время профилирования, указывают на то, что кучи памяти .NET Framework близки к максимальному размеру управляемых куч в 32-разрядном процессе. Рекомендуется повторить профилирование, используя метод профилирования памяти .NET и оптимизировать использование управляемых ресурсов приложением.|
|[DA0021. Высокая доля сборок мусора в генерации 1](../profiling/da0021-high-rate-of-gen-1-garbage-collections.md)|Относительно большое число объектов памяти .NET освобождается при сборке мусора поколения 1. Если слишком много объектов с небольшим временем существования остается после сборки поколения 0, затраты на управление памятью могут оказаться слишком высокими.|
|[DA0022. Высокая доля сборок мусора в генерации 2](../profiling/da0022-high-rate-of-gen-2-garbage-collections.md)|Большое число объектов памяти .NET освобождается при сборке мусора поколения 2. Если слишком много объектов с небольшим временем существования остается после сборки поколения 1, затраты на управление памятью могут оказаться слишком высокими. Это правило срабатывает, когда частота конфликтов блокировки превышает верхнее пороговое значение правила DA0005.|
|[DA0023. Высокое время ЦП ГК](../profiling/da0023-high-gc-cpu-time.md)|Данные о производительности системы, собранные во время профилирования, указывают, что время, затраченное на сборку мусора, весьма велико по сравнению с общим временем обработки приложения.|
|[DA0024. Избыточное время сборки мусора в ЦП](../profiling/da0024-excessive-gc-cpu-time.md)|Данные о производительности системы, собранные во время профилирования, указывают, что время, затраченное на сборку мусора, слишком велико по сравнению с общим временем обработки приложения. Это правило срабатывает, когда количество времени, затраченного на сборку мусора, превышает верхнее пороговое значение правила DA0023.|
|[DA0038. Большое число конфликтов при блокировке](../profiling/da0038-high-rate-of-lock-contentions.md)|Данные о производительности системы, собранные с помощью данных профилирования, указывают на значительно большое число конфликтов блокировки, возникающих во время выполнения приложения. Рекомендуется повторить профилирование с использованием метода профилирования параллелизма для поиска причины конфликтов.|
|[DA0039. Очень большое число конфликтов при блокировке](../profiling/da0039-very-high-rate-of-lock-contentions.md)|Данные о производительности системы, собранные с помощью данных профилирования, указывают на чрезвычайно большое число конфликтов блокировки, возникающих во время выполнения приложения. Рекомендуется повторить профилирование с использованием метода профилирования параллелизма для поиска причины конфликтов. Это правило срабатывает, когда частота конфликтов блокировки превышает верхнее пороговое значение правила DA0038.|
