---
title: Анализ загрузки ЦП в Профилировщике производительности
description: Сведения о средстве оценки производительности "Загрузка ЦП" показывает время и процент ресурсов ЦП, затраченные на выполнение кода в приложениях C++, C#, Visual Basic и JavaScript.
ms.custom: SEO-VS-2020
ms.date: 04/02/2020
ms.topic: how-to
ms.assetid: 7501a20d-04a1-480f-a69c-201524aa709d
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: a223a2007d62b84f06191c71523b861f94efe3d0
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99956130"
---
# <a name="analyze-cpu-usage-without-debugging-in-the-performance-profiler"></a>Анализ загрузки ЦП без использования отладки в Профилировщике производительности

Хороший способ начать исследование проблем производительности в приложении — определить загрузку ЦП. Средство оценки производительности **Загрузка ЦП** показывает время и процент ресурсов ЦП, затраченные на выполнение кода в приложениях C++, C#/Visual Basic и JavaScript.

Средство Загрузка ЦП может выполняться для открытого проекта Visual Studio, для установленного приложения Microsoft Store либо подключаться к запущенному приложению или процессу. Средство Загрузка ЦП можно запустить с отладкой или без нее. Дополнительные сведения см. в разделе [Запуск средств профилирования с отладчиком или без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md).

Ниже показано, как использовать средство Загрузка ЦП без отладчика, используя Профилировщик производительности Visual Studio. В примерах используется сборка выпуска на локальном компьютере. Сборки выпуска дают наилучшее представление о фактической производительности приложения. Сведения об анализе загрузки ЦП с использованием сборок отладки (с подключенным отладчиком) см. в разделе [Руководство по профилированию производительности для начинающих](../profiling/beginners-guide-to-performance-profiling.md).

Обычно выполнение установленного приложения лучше всего отражается на локальном компьютере. Чтобы собрать данные с удаленного устройства, запустите приложение непосредственно на устройстве, не используя подключение к удаленному рабочему столу.

>[!NOTE]
>Для использования [Профилировщика производительности](../profiling/profiling-feature-tour.md) требуется Windows 7 или более поздней версии.

## <a name="collect-cpu-usage-data"></a>Сбор данных об использовании ЦП

1. В проекте Visual Studio установите для решения конфигурацию **Выпуск** и выберите цель развертывания **Локальный отладчик Windows** (или **Локальный компьютер**).

    ![Выбор выпуска и локального компьютера](../profiling/media/cpuuse_selectreleaselocalmachine.png "Выбор выпуска и локального компьютера")

1. Выберите **Отладка** > **Профилировщик производительности**.

1. В разделе **Доступные инструменты** выберите **Загрузка ЦП** и затем **Запустить**.

    ![Выбор загрузки ЦП](../profiling/media/cpuuse_lib_choosecpuusage.png "Выбор загрузки ЦП")

4. После запуска приложения начинается диагностический сеанс, который отображает данные о загрузке ЦП. Когда вы закончите сбор данных, выберите **Остановить сбор данных**.

   ![Остановка сбора данных по загрузке ЦП](../profiling/media/cpu_use_wt_stopcollection.png "Остановка сбора данных по загрузке ЦП")

   Инструмент "Использование ЦП" анализирует данные и отображает отчет.

   ![Отчет по загрузке ЦП](../profiling/media/cpu_use_wt_report.png "Отчет по загрузке ЦП")

## <a name="analyze-the-cpu-usage-report"></a>Анализ отчета об использовании ЦП

Диагностический отчет отсортирован по параметру **Общая активность ЦП** в порядке убывания. Измените порядок сортировки или столбец сортировки, выбирая заголовки столбцов. Используйте раскрывающийся список **Фильтр**, чтобы выбрать или отменить выбор отображаемых потоков, и поле **Поиск**, чтобы найти определенный поток или узел.

::: moniker range=">=vs-2019"
Начиная с Visual Studio 2019, вы можете нажимать кнопки **Развернуть критический путь** и **Показать критический путь**, чтобы увидеть вызовы функций, которые используют самый высокий процент ЦП в представлении дерева вызовов.
::: moniker-end

### <a name="cpu-usage-data-columns"></a><a name="BKMK_Call_tree_data_columns"></a> Столбцы данных о загрузке ЦП

|name|Описание|
|-|-|
|**Общая активность ЦП [единица измерения, %]**|![Уравнение для общего процента](../profiling/media/cpu_use_wt_totalpercentequation.png "CPU_USE_WT_TotalPercentEquation")<br /><br /> Миллисекунды и процент ресурсов ЦП, потраченные на вызовы функции и функций, которые вызывала данная функция, в выбранный период времени. Это отличается от графика временной шкалы **Использование ЦП**, который сравнивает общую активность ЦП за период времени с общими доступными ресурсами ЦП.|
|**Собственная активность ЦП [единица измерения, %]**|![Уравнение для процента собственной активности](../profiling/media/cpu_use_wt_selflpercentequation.png "CPU_USE_WT_SelflPercentEquation")<br /><br /> Миллисекунды и процент ресурсов ЦП, потраченные на вызовы функции в выбранный период времени, за исключением функций, которые вызывала данная функция.|
|**Модуль**|Имя модуля, содержащего функцию.

### <a name="the-cpu-usage-call-tree"></a><a name="BKMK_The_CPU_Usage_call_tree"></a> Дерево вызовов средства "Использование ЦП"

Чтобы просмотреть дерево вызовов, выберите родительский узел в отчете. Открывается страница **Загрузка CPU** с представлением **Вызывающий/вызываемый**. В раскрывающемся списке **Текущее представление** выберите **Дерево вызовов**.

#### <a name="call-tree-structure"></a><a name="BKMK_Call_tree_structure"></a> Структура дерева вызовов

::: moniker range=">=vs-2019"
![Структура дерева вызовов](../profiling/media/vs-2019/cpu-use-wt-getmaxnumbercalltree-annotated.png "Структура дерева вызовов")
::: moniker-end
::: moniker range="vs-2017"
![Структура дерева вызовов](../profiling/media/cpu_use_wt_getmaxnumbercalltree_annotated.png "Структура дерева вызовов")
::: moniker-end

|Изображение|Описание|
|-|-|
|![Шаг 1](../profiling/media/procguid_1.png "ProcGuid_1")|Узел верхнего уровня в деревьях вызовов для использования ЦП представляет собой псевдоузел.|
|![Шаг 2](../profiling/media/procguid_2.png "ProcGuid_2")|В большинстве приложений при отключенном параметре **Показать внешний код** узлом второго уровня является узел **[Внешний код]** . Он содержит код системы и инфраструктуры, запускающий и останавливающий приложение, отрисовывающий пользовательский интерфейс, управляющий планированием потоков и предоставляющий приложению другие низкоуровневые службы.|
|![Шаг 3](../profiling/media/procguid_3.png "ProcGuid_3")|Дочерними элементами узла второго уровня являются методы пользовательского кода и асинхронные подпрограммы, которые вызываются или создаются кодом системы и инфраструктуры на втором уровне.|
|![Шаг 4](../profiling/media/procguid_4.png "ProcGuid_4")|Дочерние узлы метода содержат данные только для вызова родительского метода. Если параметр **Показать внешний код** отключен, методы приложения также могут содержать узел **[Внешний код]** .|

#### <a name="external-code"></a><a name="BKMK_External_Code"></a> Внешний код

Функции системы и платформы, исполняемые вашим кодом, называются *внешним кодом*. Функции внешнего кода запускают и останавливают приложение, отрисовывают пользовательский интерфейс, управляют потоками и предоставляют приложению другие низкоуровневые службы. В большинстве случаев внешний код вас интересовать не будет, поэтому дерево вызовов средства "Использование ЦП" собирает внешние функции пользовательского метода в один узел **[Внешний код]** .

Чтобы посмотреть пути вызовов внешнего кода, на главной странице диагностического отчета (область справа) выберите **Показать внешний код** в раскрывающемся списке **Фильтр** и выберите **Применить**. Представление **Дерево вызовов** на странице **Загрузка ЦП** развертывает вызовы внешнего кода. (Раскрывающийся список **Фильтр** можно найти на главной странице диагностики, а не в представлениях с подробными сведениями.)

![Показать внешний код](../profiling/media/cpu_use_wt_filterview.png "Показать внешний код")

Многие цепочки вызовов имеют глубокий уровень вложенности, поэтому ширина цепочки может превышать отображаемую ширину столбца **Имя функции**. Тогда имена функций отображаются в виде **...** .

![Вложенный внешний код в дереве вызовов](../profiling/media/cpu_use_wt_showexternalcodetoowide.png "Вложенный внешний код в дереве вызовов")

Чтобы найти имя нужной функции, используйте поле поиска. Наведите указатель мыши на выбранную строку или используйте горизонтальную полосу прокрутки для просмотра данных.

::: moniker range=">=vs-2019"
![Поиск вложенного внешнего кода](../profiling/media/vs-2019/cpu-use-wt-showexternalcodetoowide-found.png "Поиск вложенного внешнего кода")
::: moniker-end
::: moniker range="vs-2017"
![Поиск вложенного внешнего кода](../profiling/media/cpu_use_wt_showexternalcodetoowide_found.png "Поиск вложенного внешнего кода")
::: moniker-end

### <a name="asynchronous-functions-in-the-cpu-usage-call-tree"></a><a name="BKMK_Asynchronous_functions_in_the_CPU_Usage_call_tree"></a> Асинхронные функции в дереве вызовов средства "Использование ЦП"

 Если компилятор обнаруживает асинхронный метод, он создает скрытый класс для контроля выполнения этого метода. По сути, этот класс представляет собой конечный автомат. Класс содержит созданные компилятором функции, которые асинхронно вызывают исходные методы, а также обратные вызовы, планировщик и итераторы, необходимые для их выполнения. При вызове исходного метода родительским методом компилятор удаляет метод из контекста выполнения родительского метода и выполняет методы скрытого класса в контексте кода системы и платформы, который управляет выполнением приложения. Асинхронные методы часто, но не всегда выполняются в отдельном потоке (или в нескольких потоках). Этот код отображается в дереве вызовов средства **Загрузка ЦП** в виде дочерних элементов узла **[Внешний код]** сразу под верхним узлом дерева.

В следующем примере два первых узла в узле **[Внешний код]** представляют собой созданные компилятором методы класса конечного автомата. Третий узел является вызовом исходного метода.

![Асинхронный узел](media/cpu_use_wt_getmaxnumberasync_selected.png "Асинхронный узел")

Разверните созданные методы, чтобы узнать, как это работает:

![Развернутый асинхронный узел](media/cpu_use_wt_getmaxnumberasync_expandedcalltree.png "Развернутый асинхронный узел")

- `MainPage::GetMaxNumberAsyncButton_Click` просто управляет списком значений задач, вычисляет максимальное значение на основе результатов и отображает выходные данные.

- `MainPage+<GetMaxNumberAsyncButton_Click>d__3::MoveNext` показывает время ЦП, затраченное на планирование и запуск 48 задач, которые являются оболочкой вызова `GetNumberAsync`.

- `MainPage::<GetNumberAsync>b__b` показывает время ЦП, затраченное на выполнение задач, которые вызывают `GetNumber`.
