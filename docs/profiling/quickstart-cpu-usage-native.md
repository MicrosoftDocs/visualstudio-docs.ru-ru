---
title: Анализ данных о загрузке ЦП (C++)
description: Измерение производительности приложения в C++ с помощью средства диагностики "Загрузка ЦП"
ms.date: 02/14/2020
ms.topic: quickstart
f1_keywords:
- ''
helpviewer_keywords:
- Profiling Tools, quick start
- Diagnostics Tools, CPU Usage
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- cplusplus
ms.openlocfilehash: 8c68cc67d768dbe2b1c42671a02360e5cef2b56b
ms.sourcegitcommit: 01a411cd7ae3488b7b979a947bca92fd296a98e9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2021
ms.locfileid: "111760943"
---
# <a name="quickstart-analyze-cpu-usage-data-in-visual-studio-c"></a>Краткое руководство. Анализ данных по использованию ЦП в Visual Studio (C++)

Visual Studio предоставляет множество эффективных возможностей для анализа проблем с производительностью приложения. В этой статье вы ознакомитесь с некоторыми основными возможностями. Мы рассмотрим средство, позволяющее выявлять узкие места производительности, возникающие из-за высокой загрузки ЦП. Средства диагностики поддерживаются для разработки приложений .NET в Visual Studio, включая ASP.NET, и для разработки машинного кода или кода C++.

Центр диагностики предоставляет различные возможности по запуску сеансов диагностики и управлению ими. Если описываемое здесь средство **Загрузка ЦП** не предоставляет необходимые данные, можно воспользоваться [другими средствами профилирования](../profiling/profiling-feature-tour.md), предоставляющими другие виды информации, которая может оказаться полезной. Как правило, проблемы производительности приложения могут вызываться другими компонентами помимо ЦП, такими как память, отрисовка пользовательского интерфейса или время запроса сети. Профилировщик производительности предоставляет ряд других параметров для записи и анализа такого рода данных. Кроме того, используя еще одно встроенное в отладчик средство профилирования [PerfTips](../profiling/perftips.md), вы можете пошагово выполнить код и узнать, сколько времени требуется для завершения работы определенных функций или выполнения блоков кода.

Для запуска средств профилирования с отладчиком (окно **Средства диагностики**) требуется Windows 8 и более поздние версии. В Windows 7 и более поздних версиях можно использовать средство последующего анализа [Профилировщик производительности](../profiling/profiling-feature-tour.md).

## <a name="create-a-project"></a>Создание проекта

1. Откройте Visual Studio и создайте проект.

   ::: moniker range="vs-2017"
   В верхней строке меню последовательно выберите **Файл** > **Создать** > **Проект**.

   В левой области диалогового окна **Создать проект** разверните узел **Visual C++** и выберите **Рабочий стол Windows**. В средней области выберите **Консольное приложение Windows**. Назовите проект *Diagnostics_Get_Started_Native*.

   Если шаблон проекта **Приложение консоли Windows** отсутствует, щелкните ссылку **Открыть Visual Studio Installer** в левой области диалогового окна **Создать проект**. Запускается Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений на C++** , а затем нажмите **Изменить**.
   ::: moniker-end
   ::: moniker range=">=vs-2019"
   Если окно запуска не открыто, выберите **Файл** > **Окно запуска**.

   На начальном экране выберите **Создать проект**.

   В поле поиска окна **Создание проекта** введите *консоль*. Затем выберите **C++** в списке языков и **Windows** в списке платформ.

   Применив фильтры языка и платформы, выберите шаблон **Консольное приложение** и нажмите кнопку **Далее**.

   > [!NOTE]
   > Если шаблон **Консольное приложение** отсутствует, его можно установить из окна **Создание проекта**. В сообщении **Не нашли то, что искали?** выберите ссылку **Установка других средств и компонентов**. После этого в Visual Studio Installer выберите рабочую нагрузку **Разработка классических приложений на C++** .

   В поле **Имя проекта** окна **Настроить новый проект** введите *Diagnostics_Get_Started_Native*. Затем нажмите **Создать**.

   ::: moniker-end

   Новый проект открывается в Visual Studio.

1. В *Diagnostics_Get_Started_Native* замените приведенный ниже код

    ```c++
    int main()
    {
        return 0;
    }
    ```

    следующим кодом (не удаляйте `#include "stdafx.h"`):

    ```c++
    #include <iostream>
    #include <limits>
    #include <mutex>
    #include <random>
    #include <functional>

    //.cpp file code:

    static constexpr int MIN_ITERATIONS = std::numeric_limits<int>::max() / 1000;
    static constexpr int MAX_ITERATIONS = MIN_ITERATIONS + 10000;

    long long m_totalIterations = 0;
    std::mutex m_totalItersLock;

    int getNumber()
    {

        std::uniform_int_distribution<int> num_distribution(MIN_ITERATIONS, MAX_ITERATIONS);
        std::mt19937 random_number_engine; // pseudorandom number generator
        auto get_num = std::bind(num_distribution, random_number_engine);
        int random_num = get_num();

        auto result = 0;
        {
            std::lock_guard<std::mutex> lock(m_totalItersLock);
            m_totalIterations += random_num;
        }
        // we're just spinning here
        // to increase CPU usage
        for (int i = 0; i < random_num; i++)
        {
            result = get_num();
        }
        return result;
    }

    void doWork()
    {
        std::wcout << L"The doWork function is running on another thread." << std::endl;

        auto x = getNumber();
    }

    int main()
    {
        std::vector<std::thread> threads;

        for (int i = 0; i < 10; ++i) {

            threads.push_back(std::thread(doWork));
            std::cout << "The Main() thread calls this after starting the new thread" << std::endl;
        }

        for (auto& thread : threads) {
            thread.join();
        }

        return 0;
    }
    ```

## <a name="step-1-collect-profiling-data"></a>Шаг 1. Сбор данных профилирования

1. Сначала установите точку останова в приложении в следующей строке кода в функции `main`:

    `for (int i = 0; i < 10; ++i) {`

    Чтобы установить точку останова, щелкните во внешнем поле слева от строки кода.

2. Затем установите вторую точку останова в закрывающей фигурной скобке в конце функции `main`:

     ![Установка точек останова для профилирования](../profiling/media/quickstart-cpu-usage-breakpoints-cplusplus.png "Установка точек останова для профилирования")

    С помощью двух точек останова можно ограничить сбор данных частями кода, которые требуется проанализировать.

3. Окно **Средства диагностики** должно отображаться, если вы не отключали эту функцию. Чтобы снова открыть окно, щелкните **Отладка** > **Окна** > **Показать средства диагностики**.

4. Щелкните **Отладка** > **Начать отладку** (**Запустить** на панели инструментов или **F5**).

     По завершении загрузки приложения отображается представление **Сводка** Средств диагностики.

5. Приостановив отладчик, включите сбор данных по загрузке ЦП, выбрав параметр **Запись профиля ЦП**, а затем откройте вкладку **Загрузка ЦП**.

     ![Средства диагностики, Включить профилирование ЦП](../profiling/media/quickstart-cpu-usage-summary.png "Средства диагностики, Включить профилирование ЦП")

     Когда сбор данных включен, на кнопке записи отображается красный кружок.

     При выборе параметра **Запись профиля ЦП** Visual Studio начнет записывать функции и сведения о времени их выполнения, а также будет выводить временной график, с помощью которого можно сосредоточить внимание на определенных частях сеанса профилирования. Эти собранные данные можно просматривать только в том случае, если приложение останавливается в точке останова.

6. Нажмите клавишу F5, чтобы запустить приложение до второй точки останова.

     Теперь у вас есть данные о производительности приложения именно для той области кода, которая выполняется между двумя точками останова.

     Профилировщик начинает подготавливать данные потока. Дождитесь завершения этой операции.

     Средство "Загрузка ЦП" выведет отчет на вкладке **Загрузка ЦП**.

     На этом этапе можно начать анализировать данные.

## <a name="step-2-analyze-cpu-usage-data"></a>Шаг 2. Анализ данных о загрузке ЦП

Мы рекомендуем начать анализ данных с проверки списка функций на вкладке "Загрузка ЦП" и выявления функций, выполняющих основную часть работы, а затем подробно рассмотреть каждую из этих функций.

1. В списке функций изучите функции, которые выполняют большую часть работы.

     ![Вкладка "Загрузка ЦП" в средствах диагностики](../profiling/media/quickstart-cpu-usage-cpu-cplusplus.png "DiagToolsCPUUsageTab")

    > [!TIP]
    > Функции перечисляются, начиная с тех, которые выполняют большую часть работы (а не в порядке вызова). Это позволяет быстро находить функции, которые выполнялись дольше всего.

2. В списке функций дважды щелкните функцию `getNumber`.

    В левой области откроется представление **Вызывающий/вызываемый**.

    ![Представление "Вызывающий/вызываемый" в средствах диагностики](../profiling/media/quickstart-cpu-usage-caller-callee-cplusplus.png "DiagToolsCallerCallee")

    В этом представлении выбранная функция отображается в заголовке и в поле **Текущая функция** (в этом примере `getNumber`). Функция, вызывавшая текущую функцию, отображается в левой части окна в разделе **Вызывающая функция**, а все функции, вызываемые текущей функцией, отображаются в поле **Вызываемые функции** справа. (Можно выбрать любое поле, чтобы изменить текущую функцию.)

    В этом представлении показано общее время (мс) и доля общего времени выполнения приложения, затраченного на выполнение функции.

    В поле **Тело функции** также показан общий объем времени (и доля времени), затраченного в теле функции за исключением времени, затраченного в вызываемых и вызывающих функциях. (В этом примере в теле функции затрачено 119 из 43 602 мс, а остальное время затрачено в другом коде, вызванном этой функцией.) Фактические значения будут сильно отличаться в зависимости от среды.

    > [!TIP]
    > Высокие значения в поле **Тело функции** могут свидетельствовать о проблемах производительности внутри самой функции.

## <a name="next-steps"></a>Следующие шаги

- [Анализируйте использование памяти](../profiling/memory-usage.md) для выявления узких мест производительности.
- [Анализируйте загрузку ЦП](../profiling/cpu-usage.md) для получения более подробных сведений о загрузке ЦП.
- Анализируйте загрузку ЦП без подключения отладчика или путем указания выполняющегося приложения. Дополнительные сведения см. в разделе [Сбор данных профилирования без отладки](../profiling/running-profiling-tools-with-or-without-the-debugger.md#collect-profiling-data-without-debugging) и в статье [Выполнение средств профилирования с отладчиком и без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md).

## <a name="see-also"></a>См. также

- [Профилирование в Visual Studio](../profiling/index.yml)
- [Первое знакомство со средствами профилирования](../profiling/profiling-feature-tour.md)
