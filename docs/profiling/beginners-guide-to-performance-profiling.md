---
title: Измерение использования ЦП в приложениях
description: Анализ проблем с производительностью ЦП в приложении с помощью средств диагностики, встроенных в отладчик.
ms.custom: seodec18
ms.date: 04/03/2019
ms.topic: tutorial
f1_keywords:
- vs.performance.wizard.intropage
helpviewer_keywords:
- Profiling Tools, quick start
- Diagnostics Tools, CPU Usage
- CPU Usage
- Diagnostics Tools
ms.assetid: da2fbf8a-2d41-4654-a509-dd238532d25a
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: a18302067749e3b4fc70b08519056dc391d3dca4
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99936890"
---
# <a name="measure-application-performance-by-analyzing-cpu-usage"></a>Измерение производительности приложения посредством анализа использования ЦП

Средство диагностики **Использование ЦП**, интегрированное в отладчик, позволяет находить проблемы с производительностью во время отладки.  Анализировать загрузку ЦП также можно без подключения отладчика — нужно просто указать выполняющееся приложение. Дополнительные сведения см. в разделе [Запуск средств профилирования с отладчиком или без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md).

При приостановке отладчика средство **Загрузка ЦП** в окне "Средства диагностики" собирает сведения о функциях, которые выполняются в приложении. Кроме того, это средство перечисляет функции, которые выполняли максимальный объем работы, а также предоставляет график временной шкалы, который позволяет сосредоточить внимание на определенных сегментах сеанса выборки.

> [!Important]
> Средства диагностики, интегрированные в отладчик, поддерживаются для разработки приложений .NET в Visual Studio, включая ASP.NET и ASP.NET Core, и машинного кода или кода C++. Для запуска средств профилирования с отладчиком (окно **Средства диагностики**) требуется Windows 8 и более поздние версии.

В этом руководстве рассмотрены следующие задачи:

> [!div class="checklist"]
> * Сбор данных об использовании ЦП
> * Анализ данных о загрузке ЦП

Если средство **Загрузка ЦП** не предоставляет необходимые данные, можно воспользоваться другими средствами профилирования в [Профилировщике производительности](../profiling/profiling-feature-tour.md#post_mortem), предоставляющими другие виды информации, которая может оказаться полезной. Как правило, проблемы производительности приложения могут вызываться другими компонентами помимо ЦП, такими как память, отрисовка пользовательского интерфейса или время запроса сети.

## <a name="step-1-collect-profiling-data"></a>Шаг 1. Сбор данных профилирования

1. Откройте проект для отладки в Visual Studio и установите точку останова в приложении в точке, где вы хотите проверить загрузку ЦП.

2. Установите вторую точку останова в конце функции или области кода, который требуется проанализировать.

    С помощью двух точек останова можно ограничить сбор данных частями кода, которые требуется проанализировать.

3. Окно **Средства диагностики** появится автоматически, если вы не отключали эту функцию. Чтобы снова открыть окно, щелкните **Отладка** > **Окна** > **Показать средства диагностики**.

4. Вы можете выбрать, что следует просмотреть, [Использование памяти](../profiling/Memory-Usage.md) или **Загрузка ЦП** (либо оба средства), с помощью параметра **Выбор средств** на панели инструментов. В Visual Studio Enterprise также можно включить или отключить IntelliTrace, выбрав **Сервис** > **Параметры** > **IntelliTrace**.

     ![Показать средства диагностики](../profiling/media/diag-tools-select-tool.png "DiagToolsSelectTool")

     Нас главным образом интересует загрузка ЦП, поэтому убедитесь, что средство **Загрузка ЦП** включено (оно включено по умолчанию).

5. Щелкните **Отладка** > **Начать отладку** (**Запустить** на панели инструментов или **F5**).

     По завершении загрузки приложения отображается представление "Сводка" средств диагностики. Если вам нужно открыть окно, щелкните **Отладка** > **Окна** > **Показать средства диагностики**.

     ![Вкладка "Сводка средств диагностики"](../profiling/media/diag-tools-summary-tab.png "DiagToolsSummaryTab")

     Дополнительные сведения о событиях см. в разделе [Поиск и фильтрация на вкладке "События" окна "Средства диагностики"](https://devblogs.microsoft.com/devops/searching-and-filtering-the-events-tab-of-the-diagnostic-tools-window/).

6. Запустите сценарий, который вызвал срабатывание первой точки останова.

7. Приостановив отладчик, включите сбор данных о загрузке ЦП, а затем откройте вкладку **Загрузка ЦП**.

     ![Средства диагностики, включение профилирования ЦП](../profiling/media/diag-tools-enable-cpu-profiling.png "DiagToolsEnableCPUProfiling")

     При выборе пункта **Запись профиля ЦП** Visual Studio начнет записывать функции и сведения о времени их выполнения. Эти собранные данные можно просматривать только в том случае, если приложение останавливается в точке останова.

8. Нажмите клавишу F5, чтобы запустить приложение до второй точки останова.

     Теперь у вас есть данные о производительности приложения именно для той области кода, которая выполняется между двумя точками останова.

     Профилировщик начинает подготавливать данные потока. Дождитесь завершения этой операции.

     ![Средства диагностики, подготовка потоков](../profiling/media/diag-tools-preparing-data.png "DiagToolsPreparingThreads")

     Средство "Загрузка ЦП" выведет отчет на вкладке **Загрузка ЦП**.

     ![Вкладка "Загрузка ЦП" в средствах диагностики](../profiling/media/diag-tools-cpu-usage-tab.png "DiagToolsCPUUsageTab")

9. Если вы хотите выбрать для анализа более конкретную область кода, выберите область на временной шкале ЦП (это должна быть область, в которой отображаются данные профилирования).

     ![Средства диагностики, выбор сегмента временной шкалы](../profiling/media/diag-tools-select-time-segment.png "DiagToolsSelectTimeSegment")

     На этом этапе можно начать анализировать данные.

     > [!TIP]
     >  При определении проблем с производительностью рекомендуется сделать несколько измерений. Вполне естественно, что производительность варьируется от запуска к запуску, а первое выполнение путей кода обычно происходит медленнее, так как необходимо разово провести такие действия по инициализации, как загрузка библиотек DLL, JIT-компиляция методов и инициализация кэшей. Сделав несколько измерений, вы сможете лучше понять диапазон и медиану отображаемой метрики и сравнить показатель первого выполнения со стабильной производительностью области кода.

## <a name="step-2-analyze-cpu-usage-data"></a>Шаг 2. Анализ данных о загрузке ЦП

Мы рекомендуем начать анализ данных с проверки списка функций на вкладке "Загрузка ЦП" и выявления функций, выполняющих основную часть работы, а затем подробно рассмотреть каждую из этих функций.

1. В списке функций изучите функции, которые выполняют большую часть работы.

    ![Средства диагностики, список функций "Загрузка ЦП"](../profiling/media/diag-tools-cpu-usage-function-list.png "DiagToolsCPUUsageFunctionList")

    > [!TIP]
    > Функции перечисляются, начиная с тех, которые выполняют большую часть работы (а не в порядке вызова). Это позволяет быстро находить функции, которые выполнялись дольше всего.

2. В списке функций дважды щелкните одну из функций вашего приложения, которая выполняет много работы.

    При двойном щелчке функции в левой панели откроется представление **Вызывающий/вызываемый**.

    ![Представление "Вызывающий/вызываемый" в средствах диагностики](../profiling/media/diag-tools-caller-callee.png "DiagToolsCallerCallee")

    В этом представлении выбранная функции отображается в заголовке и в поле **Текущая функция** (в этом примере GetNumber). Функция, вызывавшая текущую функцию, отображается в левой части окна в разделе **Вызывающие функции**, а все функции, вызываемые текущей функцией, отображаются в поле **Вызываемые функции** справа. (Можно выбрать любое поле, чтобы изменить текущую функцию.)

    В этом представлении показано общее время (мс) и доля общего времени выполнения приложения, затраченного на выполнение функции.
    В поле **Тело функции** также показан общий объем времени (и доля времени), затраченного в теле функции за исключением времени, затраченного в вызываемых и вызывающих функциях. (В этом примере в теле функции затрачено 2367 из 2389 мс, а оставшиеся 22 мс затрачены во внешнем коде, вызванном этой функцией).

    > [!TIP]
    > Высокие значения в поле **Тело функции** могут свидетельствовать о проблемах производительности внутри самой функции.

3. Чтобы увидеть более обобщенное представление, показывающее порядок, в котором вызываются функции, выберите в раскрывающемся списке в верхней части панели пункт **Дерево вызовов**.

    Каждая нумерованная область на рисунке соответствует определенному шагу в процедуре.

    ::: moniker range=">=vs-2019"
    ![Средства диагностики, дерево вызовов](../profiling/media/vs-2019/diag-tools-call-tree.png "DiagToolsCallTree")
    ::: moniker-end
    ::: moniker range="vs-2017"
    ![Средства диагностики, дерево вызовов](../profiling/media/diag-tools-call-tree.png "DiagToolsCallTree")
    ::: moniker-end

    |Изображение|Описание|
    |-|-|
    |![Шаг 1](../profiling/media/ProcGuid_1.png "ProcGuid_1")|Узел верхнего уровня в деревьях вызовов для использования ЦП представляет собой псевдоузел|
    |![Шаг 2](../profiling/media/ProcGuid_2.png "ProcGuid_2")|В большинстве приложений при отключенном параметре [Показать внешний код](#view-external-code) узлом второго уровня является узел **[Внешний код]** , который содержит код системы и инфраструктуры, запускающий и останавливающий приложение, отрисовывающий пользовательский интерфейс, управляющий планированием потоков и предоставляющий приложению другие низкоуровневые службы.|
    |![Шаг 3](../profiling/media/ProcGuid_3.png "ProcGuid_3")|Дочерними элементами узла второго уровня являются методы пользовательского кода и асинхронные подпрограммы, которые вызываются или создаются кодом системы и инфраструктуры на втором уровне.|
    |![Шаг 4](../profiling/media/ProcGuid_4.png "ProcGuid_4")|Дочерние узлы метода содержат данные только для вызова родительского метода. Если параметр **Показать внешний код** отключен, методы приложения также могут содержать узел **[Внешний код]** .|

    Ниже приведены дополнительные сведения по значениям столбца.

    - Значение **Общее время ЦП** указывает, какой объем работы был выполнен некоторой функцией и всеми вызванными ей функциями. Высокие значения общего времени ЦП указывают на функции, которые в целом являются наиболее ресурсоемкими.

    - Значение **Собственное время** указывает, какой объем работы был выполнен кодом в теле функции, за исключением работы, выполненной вызванными ей функциями. Высокие значения **собственного времени ЦП** могут свидетельствовать о проблемах производительности внутри самой функции.

    - **Модули**. Имя модуля, содержащего функцию, или количество модулей, содержащих функции в узле [Внешний код].

    ::: moniker range=">=vs-2019"
    Чтобы увидеть вызовы функций, которые используют самый высокий процент ЦП в представлении дерева вызовов, нажмите **Развернуть критический путь**.

    ![Средства диагностики, критический путь](../profiling/media/vs-2019/diag-tools-hot-path.png "DiagToolsHotPath")
    ::: moniker-end

    > [!NOTE]
    > Если код отображается в дереве вызовов с пометкой "broken" (неработающий) или "unwalkable stack" (нетрассируемый стек), это указывает, что трассировка событий Windows, скорее всего, прервана. Для устранения проблемы попробуйте повторно выполнить ту же трассировку.

## <a name="view-external-code"></a>Просмотр внешнего кода

Внешний код — это функции в компонентах системы и платформы, которые исполняются вашим кодом. Внешний код включает функции, которые запускают и останавливают приложение, отрисовывают пользовательский интерфейс, управляют потоками и предоставляют приложению другие низкоуровневые службы. В большинстве случаев внешний код вас интересовать не будет, поэтому средство "Загрузка ЦП" собирает внешние функции пользовательского метода в один узел **[Внешний код]** .

Если вы захотите посмотреть пути к вызовам внешнего кода, выберите **Показать внешний код** в списке **Представление фильтра** и выберите **Применить**.

![Выбор списка "Представление фильтра", выбор параметра "Показать внешний код"](../profiling/media/diag-tools-show-external-code.png "DiagToolsShowExternalCode")

Помните о том, что многие цепочки вызовов имеют глубокий уровень вложенности, поэтому ширина столбца "Имя функции" может превышать ширину многих мониторов. В этом случае имена функций отображаются в виде **[…]** .

Используйте поле поиска, чтобы найти требуемый узел, а затем воспользуйтесь горизонтальной полосой прокрутки для отображения данных в представлении.

> [!TIP]
> Если вы выполняете профилирование внешнего кода, вызывающего функции Windows, следует убедиться, что используются самые новые версии *PDB*-файлов. Без этих файлов имена функций Windows в представлениях отчетов будут отображаться в непонятном или трудном для понимания виде. Дополнительные сведения о том, как убедиться в наличии нужных файлов, см. в статье [Указание файлов символов (.pdb) и файлов с исходным кодом в отладчике Visual Studio](../debugger/specify-symbol-dot-pdb-and-source-files-in-the-visual-studio-debugger.md).

## <a name="next-steps"></a>Следующие шаги

В этом руководстве вы узнали, как собирать и анализировать данные об использовании ЦП. Если вы уже ознакомились с [общими сведениями о средствах профилирования](../profiling/profiling-feature-tour.md), можно перейти к анализу данных об использовании памяти в приложениях.

> [!div class="nextstepaction"]
> [Использование памяти профиля в Visual Studio](../profiling/memory-usage.md)
