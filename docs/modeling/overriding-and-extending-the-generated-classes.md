---
title: Переопределение и расширение созданных классов
description: Узнайте, как определение DSL — это платформа, на которой можно создать мощный набор средств, основанных на предметно-ориентированном языке.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- Domain-Specific Language, providing overridable classes
author: mgoertz-msft
ms.author: mgoertz
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: 07c44e7ff7a603f339ec268b06bd78cc84cd6be2
ms.sourcegitcommit: e3a364c014ccdada0860cc4930d428808e20d667
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/19/2021
ms.locfileid: "112390949"
---
# <a name="override-and-extend-the-generated-classes"></a>Переопределение и расширение созданных классов

Определение DSL — это платформа, на которой можно создать мощный набор средств, основанных на предметно-ориентированном языке. Многие расширения и адаптации могут быть сделаны путем переопределения и расширения классов, созданных из определения DSL. Эти классы включают не только доменные классы, явно определенные на схеме определения DSL, но также и другие классы, определяющие область элементов, обозреватель, сериализацию и т. д.

## <a name="extensibility-mechanisms"></a>Механизмы расширяемости

Предусмотрено несколько механизмов, позволяющих расширить созданный код.

### <a name="override-methods-in-a-partial-class"></a>Переопределение методов в разделяемом классе

Определения разделяемых классов позволяют определять класс более чем в одном месте. Это позволяет отделить созданный код от кода, который вы пишете самостоятельно. В коде, написанном вручную, можно переопределить классы, наследуемые созданным кодом.

Например, если в определении DSL вы определили доменный класс `Book` , можно написать пользовательский код, который добавляет методы переопределения:

```csharp
public partial class Book
{
   protected override void OnDeleting()
   {
      MessageBox.Show("Deleting book " + this.Title);
      base.OnDeleting();
   }
}
```

> [!NOTE]
> Чтобы переопределить методы в созданном классе, всегда запишите код в файл, отделенный от созданных файлов. Как правило, файл содержится в папке с именем значение CustomCode. При внесении изменений в созданный код они будут потеряны при повторном создании кода из определения DSL.

Чтобы узнать, какие методы можно переопределить, введите **override** в классе, за которым следует пробел. Подсказка IntelliSense сообщит, какие методы можно переопределить.

### <a name="double-derived-classes"></a>Классы Double-Derived

Большинство методов в созданных классах наследуются от фиксированного набора классов в пространствах имен моделирования. Однако некоторые методы определяются в созданном коде. Обычно это означает, что их нельзя переопределить; нельзя переопределить в одном разделяемом классе методы, определенные в другом частичном определении того же класса.

Тем не менее, эти методы можно переопределить, установив для доменного класса флаг **Generated Double производный** . Это приводит к созданию двух классов, один из которых является абстрактным базовым классом другого. Все определения методов и свойств находятся в базовом классе, и только конструктор находится в производном классе.

Например, в образце библиотеки. DSL `CirculationBook` класс домена имеет свойство, для которого `Generates``Double Derived` задано значение `true` . Созданный код для этого доменного класса содержит два класса:

- `CirculationBookBase`, который является абстрактным и содержит все методы и свойства.

- `CirculationBook`, который является производным от `CirculationBookBase` . Он пуст, за исключением конструкторов.

Чтобы переопределить любой метод, создайте частичное определение производного класса, например `CirculationBook` . Можно переопределить как созданные методы, так и методы, унаследованные от платформы моделирования.

Этот метод можно использовать со всеми типами элементов, включая элементы модели, связи, фигуры, диаграммы и соединители. Можно также переопределить методы других созданных классов. Некоторые созданные классы, такие как Тулбоксхелпер, всегда являются двойным производным.

### <a name="custom-constructors"></a>Пользовательские конструкторы

Нельзя переопределить конструктор. Даже в классах, производных от Double, конструктор должен находиться в производном классе.

Если вы хотите предоставить собственный конструктор, это можно сделать, задав `Has Custom Constructor` для доменного класса в определении DSL. При нажатии кнопки **преобразовать все шаблоны** созданный код не будет включать конструктор для этого класса. Он будет содержать вызов отсутствующего конструктора. Это приводит к созданию отчета об ошибке при построении решения. Дважды щелкните отчет об ошибках, чтобы просмотреть комментарий в созданном коде, поясняющий, что следует предоставить.

Напишите определение разделяемого класса в файле, отдельном от создаваемых файлов, и предоставьте конструктор.

### <a name="flagged-extension-points"></a>Точки расширения с флагами

Помеченная точка расширения — это место в определении DSL, в котором можно установить свойство или флажок, чтобы указать, что будет предоставлен пользовательский метод. Одним из примеров являются пользовательские конструкторы. Другие примеры включают установку `Kind` свойства домена в вычисляемое или пользовательское хранилище или задание **пользовательского** флага в построителе подключений.

В каждом случае при установке флага и повторном создании кода будет выдаваться ошибка сборки. Дважды щелкните ошибку, чтобы просмотреть комментарий, который необходимо предоставить.

### <a name="rules"></a>Правила

Диспетчер транзакций позволяет определять правила, выполняемые до окончания транзакции, в которой произошло указанное событие, например изменение свойства. Правила обычно используются для поддержания синчронисм между различными элементами в хранилище. Например, правила используются, чтобы убедиться, что на диаграмме отображается текущее состояние модели.

Правила определяются отдельно для каждого класса, поэтому нет необходимости иметь код, регистрирующий правило для каждого объекта. Дополнительные сведения см. [в разделе правила распространяют изменения в модели](../modeling/rules-propagate-changes-within-the-model.md).

### <a name="store-events"></a>Сохранить события

Хранилище моделей предоставляет механизм событий, который можно использовать для прослушивания конкретных типов изменений в хранилище, включая добавление и удаление элементов, изменения значений свойств и т. д. Обработчики событий вызываются после закрытия транзакции, в которой были внесены изменения. Как правило, эти события используются для обновления ресурсов за пределами хранилища.

### <a name="net-events"></a>События .NET

Вы можете подписываться на некоторые события в фигурах. Например, можно ожидать щелчков мышью на фигуре. Необходимо написать код, который подписывается на событие для каждого объекта. Этот код можно написать с помощью переопределения Инитиализеинстанцересаурцес ().

Некоторые события создаются в ShapeFields, которые используются для рисования декораторов на фигуре. Пример см. в разделе [как перехватить щелчок фигуры или декоратора](../modeling/how-to-intercept-a-click-on-a-shape-or-decorator.md).

Эти события обычно не возникают внутри транзакции. Если необходимо внести изменения в хранилище, следует создать транзакцию.
