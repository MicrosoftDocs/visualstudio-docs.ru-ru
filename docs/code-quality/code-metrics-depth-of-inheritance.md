---
title: Метрики кода — глубина наследования
ms.date: 1/8/2021
description: Сведения о глубине наследования метрик кода в Visual Studio.
ms.topic: conceptual
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: 1d6ac085463087fc73aac4429488ab475e91c10f
ms.sourcegitcommit: cc66c898ce82f9f1159bd505647f315792cac9fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/10/2021
ms.locfileid: "109682580"
---
# <a name="code-metrics---depth-of-inheritance-dit"></a>Метрики кода — глубина наследования (DIT)

В этой статье вы узнаете об одной из метрик, разработанных специально для объектно-ориентированного анализа: глубина наследования. Глубина наследования, также называемая глубиной дерева наследования (DIT), определена как "максимальная длина от узла до корня дерева" [CK](#ck). Это можно увидеть с помощью простого примера. Создайте новый проект библиотеки классов и, прежде чем писать код, вычислите метрики кода, выбрав **анализ > рассчитать метрики кода для решения**.

![Глубина примера наследования 1](media/depth-of-inheritance-example-1.png)

Поскольку все классы наследуют от `System.Object` , в настоящее время глубина равна 1. Если вы наследуете от этого класса и проверите новый класс, можно увидеть результат:

![Глубина наследования, пример 2](media/depth-of-inheritance-example-2.png)

Обратите внимание, что чем меньше узел в дереве ( `Class2` в данном случае), тем выше глубина наследования. Вы можете продолжить создавать дочерние элементы и увеличить глубину по мере необходимости.

## <a name="assumptions"></a>Предположения

Глубина наследования задается в трех основных допущениях [CK](#ck):

1. Чем глубже класс в иерархии, тем больше число методов, которые он может наследовать, что усложняет прогнозирование его поведения.

2. Более глубокие деревья требуют большей сложности проектирования, поскольку задействованы дополнительные классы и методы.

3. Более глубокие классы в дереве имеют больший потенциал для повторного использования наследуемых методов.

Предположения 1 и 2 сообщают о том, что более высокое значение глубины является недопустимым. Если это место завершения, вы бы хотели иметь хорошее значение. Однако предположение 3 указывает, что более высокое значение глубины подходит для потенциального повторного использования кода.

## <a name="analysis"></a>Анализ

Вот как вы читаете метрику глубины:

- Низкое значение глубины

  Низкое значение глубины требует меньшей сложности, но также уменьшает вероятность повторного использования кода посредством наследования.

- Большое число для глубины

  Большое число для глубины требует более возможного повторного использования кода путем наследования, но также повышает сложность с большей вероятностью ошибок в коде.

## <a name="code-analysis"></a>Анализ кода

Анализ кода включает категорию правил сопровождения. Дополнительные сведения см. в разделе [правила удобства поддержки](/dotnet/fundamentals/code-analysis/quality-rules/maintainability-warnings). При использовании анализа кода прежних версий расширенный набор правил по проектированию содержит область обслуживания:

![Глубина рекомендаций по проектированию наследования. наборы правил](media/depth-of-inheritance-design-guidelines.png)

Внутри области обслуживания находится правило наследования:

![Глубина правила сопровождения наследования](media/depth-of-inheritance-maintainability-rule.png)

Это правило выдает предупреждение, когда глубина наследования достигнет 6 или выше, поэтому это хорошее правило, помогающее предотвратить чрезмерное наследование. Дополнительные сведения о правиле см. в разделе [CA1501](/dotnet/fundamentals/code-analysis/quality-rules/ca1501).

## <a name="putting-it-all-together"></a>Совместное размещение

Высокие значения для DIT означают, что вероятность ошибок также высока, а низкие значения снижают вероятность ошибок. Высокие значения для DIT указывают на больший потенциал повторного использования кода посредством наследования, а низкие значения предлагают меньше повторного использования кода, хотя наследование используется. В связи с отсутствием достаточного объема данных в настоящее время для значений DIT не принято. Даже недавно выполненные исследования не нашли достаточно данных для определения допустимого числа, которое можно использовать в качестве стандартного числа для этой метрики [шатнави](#shatnawi). Хотя для поддержки этого не существует экспериментов, некоторые ресурсы предполагают, что дерево каталогов, около 5 или 6, должно быть верхней границей. Например, см [http://www.devx.com/architect/Article/45611](http://www.devx.com/architect/Article/45611) . раздел.

## <a name="citations"></a>Цитат

### <a name="ck"></a>CK

Чидамбер, S. R. & Кемерер, C. F. (1994). Набор метрик для объектно-ориентированного проектирования (IEEE Transactions on Software Engineering, vol. 20, No. 6). Получено 14 мая 2011 с веб-сайта университета Pittsburgh: [http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf](http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf)

### <a name="krishnan"></a>Кришнан (

Субраманям, R. & Кришнан (, M. S. (2003). Опытный анализ метрик CK для Object-Oriented сложность проектирования: влияние на дефекты программного обеспечения (IEEE Transactions on Software Engineering, vol. 29, No. 4). Получено 14 мая 2011, первоначально полученное из университета веб-сайта Массачусетс Дартмаус [https://ieeexplore.ieee.org/abstract/document/1191795](https://ieeexplore.ieee.org/abstract/document/1191795)

### <a name="shatnawi"></a>шатнави

Шатнави, R. (2010). Количественное исследование приемлемых уровней риска Object-Oriented метрик в системах Open-Source (IEEE Transactions on Software Engineering, vol. 36, No. 2).