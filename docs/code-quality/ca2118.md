---
title: CA2118. Проверьте использование атрибута SuppressUnmanagedCodeSecurityAttribute
description: Открытый или защищенный тип или член имеет атрибут System. Security. SuppressUnmanagedCodeSecurityAttribute.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA2118
- ReviewSuppressUnmanagedCodeSecurityUsage
helpviewer_keywords:
- ReviewSuppressUnmanagedCodeSecurityUsage
- CA2118
ms.assetid: 4cb8d2fc-4e44-4dc3-9b74-7f5838827d41
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- cplusplus
ms.openlocfilehash: bdeff1fd466fd64edee768d68e5d942656087261
ms.sourcegitcommit: a339547aa2f4e0f64b7afbcc3e1ade0a4f9287d2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2021
ms.locfileid: "106170995"
---
# <a name="ca2118-review-suppressunmanagedcodesecurityattribute-usage"></a>CA2118. Проверьте использование атрибута SuppressUnmanagedCodeSecurityAttribute

|Элемент|Значение|
|-|-|
|Идентификатор правила|CA2118|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина
Открытый или защищенный тип или член имеет <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute?displayProperty=fullName> атрибут.

> [!NOTE]
> Это правило было признано устаревшим. Дополнительные сведения см. в разделе [устаревшие правила](fxcop-unported-deprecated-rules.md).

## <a name="rule-description"></a>Описание правила

<xref:System.Security.SuppressUnmanagedCodeSecurityAttribute> изменяет поведение системы безопасности по умолчанию для элементов, выполняющих неуправляемый код с помощью COM-взаимодействия или вызова платформы. Как правило, система создает [данные и выполняет моделирование](/dotnet/framework/data/index) для разрешения неуправляемого кода. Это требование происходит во время выполнения для каждого вызова члена и проверяет наличие разрешения у всех вызывающих объектов в стеке вызовов. При наличии атрибута система устанавливает [требование ссылки](/dotnet/framework/misc/link-demands) на разрешение: разрешения непосредственного вызывающего объекта проверяются при JIT-компиляции вызывающего объекта.

Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности. Если поместить атрибут в открытые члены, вызывающие собственные методы, вызывающим объектам в стеке вызовов (кроме непосредственный вызывающей стороной) не требуется разрешение неуправляемого кода для выполнения неуправляемого кода. В зависимости от действий открытого члена и обработки входных данных это может позволить ненадежным вызывающим объектам получать доступ к функциональным возможностям, которые обычно ограничены надежным кодом.

.NET использует проверки безопасности, чтобы предотвратить получение вызывающими объектами прямого доступа к адресному пространству текущего процесса. Поскольку этот атрибут обходит обычную безопасность, код создает серьезную угрозу, если ее можно использовать для чтения или записи в память процесса. Обратите внимание, что риск не ограничен методами, которые намеренно предоставляют доступ к памяти процесса; Он также имеется в любом сценарии, где вредоносный код может получить доступ с помощью любого средства, например, с неправильным, неправильно сформированным или недопустимым входом.

Политика безопасности по умолчанию не предоставляет сборке разрешение на неуправляемый код для сборки, если она не выполняется с локального компьютера или является членом одной из следующих групп:

- Группа кода зоны Мой компьютер

- Группа кода строгого имени (Майкрософт)

- Группа кода строгого имени ECMA

## <a name="how-to-fix-violations"></a>Устранение нарушений

Внимательно проверьте код, чтобы убедиться в том, что этот атрибут является абсолютно необходимым. Если вы не знакомы с безопасностью управляемого кода или не понимаете последствия использования этого атрибута в безопасности, удалите его из кода. Если атрибут является обязательным, необходимо убедиться, что вызывающие объекты не могут использовать ваш код злонамеренно. Если код не имеет разрешения на выполнение неуправляемого кода, этот атрибут не действует и должен быть удален.

## <a name="when-to-suppress-warnings"></a>Условия для отключения предупреждений

Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться в том, что код не предоставляет вызывающим объектам доступ к собственным операциям или ресурсам, которые могут быть использованы необратимым образом.

## <a name="example-1"></a>Пример 1

В следующем примере нарушается правило.

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.TypesDoNotSuppress/cs/FxCop.Security.TypesDoNotSuppress.cs" id="Snippet1":::

## <a name="example-2"></a>Пример 2

В следующем примере `DoWork` метод предоставляет общедоступный путь кода к методу вызова платформы `FormatHardDisk` .

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.PInvokeAndSuppress/cs/FxCop.Security.PInvokeAndSuppress.cs" id="Snippet1":::

## <a name="example-3"></a>Пример 3

В следующем примере открытый метод `DoDangerousThing` вызывает нарушение. Чтобы устранить нарушение, `DoDangerousThing` следует сделать частным, и доступ к нему должен осуществляться через открытый метод, защищенный требованием безопасности, как показано в `DoWork` методе.

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.TypeInvokeAndSuppress/cs/FxCop.Security.TypeInvokeAndSuppress.cs" id="Snippet1":::

## <a name="see-also"></a>См. также раздел

- <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute?displayProperty=fullName>
- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Данные и моделирование](/dotnet/framework/data/index)
- [Требования связывания](/dotnet/framework/misc/link-demands)
