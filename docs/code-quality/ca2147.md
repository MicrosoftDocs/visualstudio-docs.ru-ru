---
title: CA2147. Прозрачные методы могут не использовать утверждения безопасности
description: Коду, помеченному как System. Security. SecurityTransparentAttribute, не предоставлены достаточные разрешения для утверждения.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- SecurityTransparentCodeShouldNotAssert
- CA2147
- CA2128
helpviewer_keywords:
- CA2128
- SecurityTransparentCodeShouldNotAssert
ms.assetid: 5d31e940-e599-4b23-9b28-1c336f8d910e
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: e4aa715370a5e35f2a5c365682155db5b8b17bdb
ms.sourcegitcommit: 162be102d2c22a1c4ad2c447685abd28e0e85d15
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2021
ms.locfileid: "109973496"
---
# <a name="ca2147-transparent-methods-may-not-use-security-asserts"></a>CA2147. Прозрачные методы могут не использовать утверждения безопасности

|Элемент|Значение|
|-|-|
|Идентификатор правила|CA2147|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина
Коду, помеченному как, <xref:System.Security.SecurityTransparentAttribute> не предоставлены достаточные разрешения для утверждения.

> [!NOTE]
> Это правило было признано устаревшим. Дополнительные сведения см. в разделе [устаревшие правила](fxcop-unported-deprecated-rules.md).

## <a name="rule-description"></a>Описание правила
Это правило анализирует все методы и типы в сборке, которая имеет значение 100% прозрачная или смешанная прозрачная или критическая, и помечает любое декларативное или императивное использование <xref:System.Security.CodeAccessPermission.Assert%2A> .

Во время выполнения любые вызовы <xref:System.Security.CodeAccessPermission.Assert%2A> из прозрачного кода приведут к возникновению <xref:System.InvalidOperationException> исключения. Это может происходить как в 100% прозрачных сборках, так и в смешанных прозрачных и критических сборках, где метод или тип объявлен как прозрачный, но включает декларативное или императивное утверждение.

В платформа .NET Framework 2,0 появилась функция с именем *прозрачность*. Отдельные методы, поля, интерфейсы, классы и типы могут быть либо прозрачными, либо критически важными.

Прозрачный код не может повышать привилегии безопасности. Таким образом, любые разрешения, предоставленные или запрошенные им, автоматически передаются через код вызывающему или ведущему домену приложения. Примеры повышения прав включают утверждения, LinkDemands, Суппрессунманажедкоде и `unsafe` код.

## <a name="how-to-fix-violations"></a>Устранение нарушений
Чтобы устранить эту проблему, либо пометьте код, вызывающий утверждение, с <xref:System.Security.SecurityCriticalAttribute> , либо удалите утверждение.

## <a name="when-to-suppress-warnings"></a>Условия для отключения предупреждений
Для этого правила отключать вывод предупреждений не следует.

## <a name="example-1"></a>Пример 1
Этот код завершится ошибкой `SecurityTestClass` , если является прозрачным, когда `Assert` метод создает исключение <xref:System.InvalidOperationException> .

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/fxcop.security.ca2147.transparentmethodsmustnotusesecurityasserts/cs/ca2147-transparentmethodsmustnotusesecurityasserts.cs" id="Snippet1":::

## <a name="example-2"></a>Пример 2
Один из вариантов — код, приведенный в примере ниже, и если метод считается безопасным для повышения прав, пометьте Секурититранспарентмесод с критически важным для безопасности. Для этого необходимо, чтобы в методе были выполнены аудит безопасности с подробным завершением и без ошибок, а также все вызовы, происходящие в методе в утверждении.

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.SecurityTransparentCode2/cs/FxCop.Security.SecurityTransparentCode2.cs" id="Snippet1":::

Кроме того, можно удалить утверждение из кода и позволить всем последующим запросам на разрешение ввода-вывода выполнять потоки, расположенные за пределами Секурититранспарентмесод, на вызывающий объект. Это обеспечивает проверку безопасности. В этом случае аудит безопасности не требуется, так как требования к разрешениям будут передаваться вызывающему и (или) домену приложения. Требования к разрешениям тесно контролируются с помощью политик безопасности, среды размещения и разрешений исходного кода.

## <a name="see-also"></a>См. также раздел
[Предупреждения системы безопасности](/dotnet/fundamentals/code-analysis/quality-rules/security-warnings)
