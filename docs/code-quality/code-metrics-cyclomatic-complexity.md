---
title: Метрики кода — сложность сложностью организации циклов
ms.date: 5/7/2021
description: Сведения о показателе сложности сложностью организации циклов для метрик кода в Visual Studio.
ms.topic: conceptual
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: 1798b0faa1b0cf44ae490f5b27571e5466b82ca9
ms.sourcegitcommit: cc66c898ce82f9f1159bd505647f315792cac9fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/10/2021
ms.locfileid: "109682576"
---
# <a name="code-metrics---cyclomatic-complexity"></a>Метрики кода — сложность сложностью организации циклов

При работе с метриками кода один из наиболее понятных элементов кажется сложностью организации циклов сложным. По сути, с сложностью организации циклов сложность, более высокие значения являются неправильными, а меньшие числа — хорошим. Сложностью организации циклов сложность позволяет понять, насколько сложно заданный код для тестирования, обслуживания или устранения неполадок, а также указывает, насколько вероятно, что код будет выдавать ошибки. На высоком уровне мы определяем значение сложности сложностью организации циклов, подчисляя количество решений, принятых в исходном коде. В этой статье вы начинаете с простого примера сложности сложностью организации циклов, чтобы быстро понять концепцию, а затем рассмотрим некоторую дополнительную информацию о фактическом использовании и рекомендуемых ограничениях. Наконец, есть раздел с ссылками, которые можно использовать для углубленного изучения этой темы.

## <a name="example"></a>Пример

Сложность сложностью организации циклов определяется как измерение объема логики принятия решений в функции исходного кода " [NIST235](#nist235). Проще говоря, чем больше решений, которые должны быть сделаны в коде, тем сложнее.

Давайте посмотрим на это в действии. Создайте новое консольное приложение и сразу Вычислите метрики кода, выполнив **анализ > рассчитать метрики кода для решения**.

![Пример сложности сложностью организации циклов 1](media/cyclomatic-complexity-example-1.png)

Обратите внимание, что сложностью организации циклов сложность составляет 2 (наименьшее значение). При добавлении кода, не относящегося к решению, обратите внимание на то, что сложность не меняется:

![Пример сложности сложностью организации циклов 2](media/cyclomatic-complexity-example-2.png)

Если вы добавляете решение, значение сложности сложностью организации циклов проходит до 1:

![Пример сложности сложностью организации циклов 3](media/cyclomatic-complexity-example-3.png)

При изменении оператора if на оператор switch с принятием 4 принятия решений он переходит с исходного 2 на 6:

![Пример сложности сложностью организации циклов 4](media/cyclomatic-complexity-example-4.png)

Давайте рассмотрим (гипотетическую) большую базу кода.

![Пример сложности сложностью организации циклов 5](media/cyclomatic-complexity-example-5.png)

Обратите внимание, что большинство элементов при детализации класса Products_Related имеют значение 1, но несколько из них имеют сложность 5. Само по себе, это может быть не так уж много, но, учитывая, что большинство других членов имеют 1 в одном классе, вы должны внимательно взгляните на эти два элемента и посмотрим, что в них есть. Это можно сделать, щелкнув элемент правой кнопкой мыши и выбрав пункт **Перейти к исходному коду** из контекстного меню. Внимательно взгляните на `Product.set(Product)` :

![Пример сложности сложностью организации циклов 6](media/cyclomatic-complexity-example-6.png)

Учитывая все операторы If, можно увидеть, почему сложность сложностью организации циклов составляет 5. На этом этапе вы можете решить, что это приемлемый уровень сложности, или же вы можете выполнить рефакторинг, чтобы снизить сложность.

## <a name="the-magic-number"></a>Магическое число

Как и в случае с множеством метрик в этой отрасли, не существует точного ограничения сложностью организации циклов сложности, удовлетворяющего всем организациям. Однако [NIST235](#nist235) указывает, что ограничение в 10 является хорошей отправной точкой:

"Точное число для использования в качестве ограничения, однако, остается несколько спорной. Исходное ограничение в 10, как предложено Мккабе, имеет существенные вспомогательные доказательства, но все ограничения также были успешно использованы. Ограничения свыше 10 должны быть зарезервированы для проектов, имеющих несколько операционных преимуществ по сравнению с обычными проектами, например опытный персонал, формальный дизайн, современный язык программирования, структурированное программирование, пошаговое руководство по коду и полный план тестирования. Иными словами, Организация может выбрать ограничение сложности более 10, но только в том случае, если известно, что она делает, и хочет полагаться на дополнительные усилия по тестированию, необходимые для более сложных модулей. " [NIST235](#nist235)

## <a name="cyclomatic-complexity-and-line-numbers"></a>Сложностью организации циклов сложность и номера строк

Просто взглянув на количество строк кода само по себе, это, в лучшем смысле, очень широкий прогноз качества кода. Есть некоторые базовые мысли о том, что чем больше строк кода в функции, тем больше вероятность возникновения ошибок. Однако при сочетании сложности сложностью организации циклов с строками кода вы получите намного более четкое представление о возможностях ошибок.

Как описано в центре Software Assurance (САТК) в NASA:

"САТК обнаружил наиболее эффективную оценку — сочетание размера и сложности (сложностью организации циклов). Модули с высоким уровнем сложности и большим размером обычно имеют наименьшую надежность. Модули с низким и высоким уровнем сложности также являются риском надежности, так как они, как правило, являются очень сжатым кодом, что сложно изменить или изменить. [сатк](#satc)

## <a name="code-analysis"></a>Анализ кода

Анализ кода включает категорию правил сопровождения. Дополнительные сведения см. в разделе [правила удобства поддержки](/dotnet/fundamentals/code-analysis/quality-rules/maintainability-warnings). При использовании анализа кода прежних версий расширенный набор правил по проектированию содержит область обслуживания:

![Рекомендации по проектированию сложности сложностью организации циклов. наборы правил](media/cyclomatic-complexity-design-guidelines.png)

Внутри области обслуживания находится правило сложности:

![Правило поддержки сложности сложностью организации циклов](media/cyclomatic-complexity-maintainability-rule.png)

Это правило выдает предупреждение, когда сложностью организации циклов сложность достигает 25, поэтому она может помочь избежать чрезмерной сложности. Дополнительные сведения о правиле см. в разделе [CA1502](/dotnet/fundamentals/code-analysis/quality-rules/ca1502)

## <a name="putting-it-all-together"></a>Совместное размещение

В конце концов, высокий уровень сложности означает большую вероятность ошибок с увеличением времени для обслуживания и устранения неполадок. Внимательно ознакомьтесь с любыми функциями, которые имеют высокую сложность, и решите, следует ли рефакторингировать их, чтобы сделать их менее сложными.

## <a name="citations"></a>Цитат

### <a name="mccabe5"></a>MCCABE5

Мккабе, T. и. Watson (1994), сложность программного обеспечения (Кроссталк: журнал обороны программного обеспечения).

### <a name="nist235"></a>NIST235

Ватсон, A. H., & Мккабе, T. J. (1996). Структурированное тестирование. Методология тестирования с использованием метрики сложности сложностью организации циклов (специальная публикация NIST 500-235). Получено 14 мая 2011 с веб-сайта Мккабе Software: [http://www.mccabe.com/pdf/mccabe-nist235r.pdf](http://www.mccabe.com/pdf/mccabe-nist235r.pdf)

### <a name="satc"></a>сатк

РОСЕНБЕРГ, L., нагный, п., Shaw), J. (1998). Метрики и надежность программного обеспечения (материалы стандарта IEEE International Symposium при проектировании надежности программного обеспечения). Получено 14 мая 2011 с веб-сайта университета состояния Пенн: [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4041&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4041&rep=rep1&type=pdf)