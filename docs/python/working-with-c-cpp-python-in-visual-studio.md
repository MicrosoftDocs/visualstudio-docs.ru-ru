---
title: Создание расширений C++ для Python
description: Пошаговое руководство по созданию расширения C++ для Python с помощью Visual Studio, CPython и PyBind11, включая отладку в смешанном режиме.
ms.date: 05/11/2021
ms.topic: how-to
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.custom: seodec18
ms.workload:
- python
- data-science
ms.openlocfilehash: 286d5f2c316379316b1a1cf55334cab39cdc247c
ms.sourcegitcommit: 69256dc47489853dc66a037f5b0c1275977540c0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2021
ms.locfileid: "109782638"
---
# <a name="create-a-c-extension-for-python"></a>Создание расширения C++ для Python

Модули, написанные на C++ (или C), обычно используются для расширения возможностей интерпретатора Python, а также для доступа к низкоуровневым возможностям операционной системы. Существует три основных типа модулей:

- Модули акселератора: так как Python — это интерпретируемый язык, для повышения производительности некоторые фрагменты кода могут быть написаны на C++.
- Модули оболочки: предоставляют существующие интерфейсы C/C++ для кода Python или адаптированный API, который удобно использовать в Python.
- Модули низкоуровневого системного доступа: созданы для доступа к низкоуровневым функциям среды выполнения `CPython`, операционной системы и базового оборудования.

В этой статье рассматривается создание модуля расширения C++ для `CPython`, вычисляющего гиперболический тангенс и вызывающего его из кода Python. Подпрограмма реализована сначала на языке Python, чтобы продемонстрировать относительный прирост производительности по сравнению с реализацией той же подпрограммы на C++.

В этой статье также показаны два способа сделать C++ доступным для Python:

- Стандартные расширения `CPython`, как описано в [документации по Python](https://docs.python.org/3/c-api/).
- [PyBind11](https://github.com/pybind/pybind11) (рекомендуется для C++ 11 благодаря своей простоте).

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).

## <a name="prerequisites"></a>Предварительные требования

- Visual Studio 2017 или более поздней версии с установленной рабочей нагрузкой **Разработка на Python**, включая **собственные средства разработки Python**, которые содержат рабочую нагрузку C++ и наборы инструментов, необходимые для собственных расширений.

    ![Выбор параметра "Собственные средства разработки Python"](media/cpp-install-native.png)

    > [!Tip]
    > При установке рабочей нагрузки **Приложения для обработки и анализа данных и аналитические приложения** по умолчанию включаются среда Python и параметр **Собственные средства разработки Python**.

Дополнительные сведения о параметрах установки см. в статье [Как установить поддержку Python в Visual Studio под управлением Windows](installing-python-support-in-visual-studio.md). Если вы устанавливаете Python отдельно, обязательно выберите параметр **Скачать отладочные символы** в разделе **Дополнительные параметры** установщика. Этот параметр необходим для использования отладки в смешанном режиме между кодом Python и машинным кодом.

## <a name="create-the-python-application"></a>Создание приложения Python

1. Создайте проект Python в Visual Studio, выбрав **Файл** > **Создать** > **Проект**. Выполните поиск слова "Python", выберите шаблон **Приложение Python**, назначьте ему подходящее имя и расположение, а затем нажмите кнопку **ОК**.

1. В файл *.py* проекта вставьте приведенный ниже код (или введите его вручную, чтобы опробовать некоторые [возможности редактирования Python](editing-python-code-in-visual-studio.md)). Этот код вычислит гиперболический тангенс без использования математической библиотеки и ускорит работу с собственными расширениями.

    > [!Tip]
    > Прежде чем переписывать код на C++, напишите его исключительно на Python. Таким образом можно легко проверить правильность машинного кода

    ```python
    from random import random
    from time import perf_counter

    COUNT = 500000  # Change this value depending on the speed of your computer
    DATA = [(random() - 0.5) * 3 for _ in range(COUNT)]

    e = 2.7182818284590452353602874713527

    def sinh(x):
        return (1 - (e ** (-2 * x))) / (2 * (e ** -x))

    def cosh(x):
        return (1 + (e ** (-2 * x))) / (2 * (e ** -x))

    def tanh(x):
        tanh_x = sinh(x) / cosh(x)
        return tanh_x

    def test(fn, name):
        start = perf_counter()
        result = fn(DATA)
        duration = perf_counter() - start
        print('{} took {:.3f} seconds\n\n'.format(name, duration))

        for d in result:
            assert -1 <= d <= 1, " incorrect values"

    if __name__ == "__main__":
        print('Running benchmarks with COUNT = {}'.format(COUNT))

        test(lambda d: [tanh(x) for x in d], '[tanh(x) for x in d] (Python implementation)')
    ```

1. Запустите программу с помощью команды **Отладка** > **Запуск без отладки** (или нажмите клавиши **CTRL**+**F5**), чтобы просмотреть результаты. Чтобы изменить длительность выполнения тестов производительности, можно настроить переменную `COUNT`. В целях этого руководства задайте значение так, чтобы тест производительности занимал приблизительно две секунды.

> [!TIP]
> При выполнении тестов производительности всегда выбирайте **Отладка** > **Запуск без отладки** во избежание издержки при выполнении кода в отладчике Visual Studio.

## <a name="create-the-core-c-projects"></a>Создание основных проектов C++

Следуйте инструкциям в этом разделе, чтобы создать два идентичных проекта C++ с именами superfastcode и superfastcode2. Позже вы будете использовать в каждом проекте два подхода предоставления кода C++ для Python.

1. Щелкните решение в **обозревателе решений** правой кнопкой мыши и выберите **Добавить** > **Новый проект**. Решение Visual Studio может одновременно содержать проекты Python и C++ (одно из преимуществ использования Visual Studio для Python).

1. Выполните поиск "C++", выберите **Пустой проект**, укажите имя superfastcode (superfastcode2 для второго проекта) и выберите **ОК**.

    > [!Tip]
    > Если вы уже установили **собственные средства разработки Python** в Visual Studio, то можете начать с шаблона **Модуль расширения Python**, который уже содержит большую часть описываемых ниже функций. Но в этом пошаговом руководстве начало работы с пустого проекта позволяет шаг за шагом продемонстрировать создание модуля расширения. Когда вы освоите процесс, шаблон позволит вам сэкономить время при написании собственных расширений.

1. Создайте файл C++ в новом проекте. Для этого щелкните правой кнопкой мыши узел **Исходные файлы** и выберите **Добавить** > **Новый элемент**, затем выберите **Файл C++**, присвойте ему имя `module.cpp` и нажмите кнопку **ОК**.

    > [!Important]
    > Файл с расширением *.cpp* нужен, чтобы активировать страницы свойств C++ в последующих шагах.

1. Если вы используете 64-разрядную среду выполнения Python, активируйте конфигурацию **x64** с помощью раскрывающегося меню на главной панели инструментов. Для 32-разрядной среды выполнения Python следует активировать конфигурацию **Win32**.

1. В **обозревателе решений** щелкните проект C++ правой кнопкой мыши и выберите пункт **Свойства**. Значение параметра **Конфигурация** должно быть **Активна (Отладка)** , параметр **Платформа** должен иметь значение **Активна (x64)** или **Активна (Win32)** в зависимости от выбора на предыдущем шаге.

    > [!Tip]
    > Для собственных проектов потребуется настроить конфигурации отладки и выпуска. Здесь мы настроим только конфигурацию отладки для использования сборки *выпуска* `CPython`. При этом некоторые функции отладки среды выполнения C++, включая утверждения, отключаются. Для использования двоичных файлов *отладки* `CPython` (`python_d.exe`) потребуется указать другие параметры.

1. Задайте определенные свойства, как описано в таблице ниже, а затем нажмите кнопку **ОК**.
    ::: moniker range=">=vs-2019"
    | Вкладка | Свойство | Значение |
    | --- | --- | --- |
    | **Общие** | **Имя цели** | Укажите имя модуля, которое будет использоваться из Python в инструкциях `from...import`. Это же имя используется в C++ при определении модуля для Python. Если вы хотите применять имя проекта в качестве имени модуля, сохраните значение по умолчанию **$(ProjectName)**. Для `python_d.exe` добавьте `_d` в конец файла. |
    | | **Тип конфигурации** | **Динамическая библиотека (.dll)** |
    | **Дополнительно** | **Расширение целевого файла** | **.pyd** |
    | **C/C++** > **Общие** | **Дополнительные каталоги включаемых файлов** | Добавьте подходящую для вашей установки папку *include* Python, например `c:\Python36\include`.  |
    | **C/C++** > **Препроцессор** | **Определения препроцессора** | При наличии измените значение **_DEBUG** на **NDEBUG** для соответствия версии `CPython`, отличной от отладочной. (Если используется `python_d.exe`, оставьте без изменений.) |
    | **C/C++** > **Создание кода** | **Библиотека времени выполнения** | **Многопоточная библиотека DLL (/MD)** в соответствии с версией `CPython`, отличной от отладочной. (Если используется `python_d.exe`, оставьте без изменений.) |
    | **Компоновщик** > **Общие** | **Дополнительные каталоги библиотек** | Добавьте подходящую для вашей установки папку Python *libs* с файлами *.lib*, например `c:\Python36\libs`. (Обязательно укажите папку *libs*, содержащую файлы *.lib*, но *не* папку *LIb*, содержащую файлы *.py*.) |
    ::: moniker-end
    ::: moniker range="=vs-2017"
    | Вкладка | Свойство | Значение |
    | --- | --- | --- |
    | **Общие** | **Общие** > **Имя целевого объекта** | Укажите имя модуля, которое будет использоваться из Python в инструкциях `from...import`. Это же имя используется в C++ при определении модуля для Python. Если вы хотите применять имя проекта в качестве имени модуля, сохраните значение по умолчанию **$(ProjectName)**. Для `python_d.exe` добавьте `_d` в конец файла. |
    | | **Общие** > **Конечное расширение** | **.pyd** |
    | | **Значения по умолчанию для проекта** > **Тип конфигурации** | **Динамическая библиотека (.dll)** |
    | **C/C++** > **Общие** | **Дополнительные каталоги включаемых файлов** | Добавьте подходящую для вашей установки папку *include* Python, например `c:\Python36\include`.  |
    | **C/C++** > **Препроцессор** | **Определения препроцессора** | При наличии измените значение **_DEBUG** на **NDEBUG** для соответствия версии `CPython`, отличной от отладочной. (Если используется `python_d.exe`, оставьте без изменений.) |
    | **C/C++** > **Создание кода** | **Библиотека времени выполнения** | **Многопоточная библиотека DLL (/MD)** в соответствии с версией `CPython`, отличной от отладочной. (Если используется `python_d.exe`, оставьте без изменений.) |
    | **Компоновщик** > **Общие** | **Дополнительные каталоги библиотек** | Добавьте подходящую для вашей установки папку Python *libs* с файлами *.lib*, например `c:\Python36\libs`. (Обязательно укажите папку *libs*, содержащую файлы *.lib*, но *не* папку *LIb*, содержащую файлы *.py*.) |
    ::: moniker-end
    
    > [!Tip]
    > Если вы не видите вкладку C/C++ в свойствах проекта, значит, в проекте нет файлов, определенных как исходные файлы C и C++. Такая ситуация может возникнуть, если вы создали исходный файл без расширения *.c* или *.cpp*. Например, если ранее вы случайно ввели `module.coo` вместо `module.cpp` в диалоговом окне создания элемента, Visual Studio создаст файл, но не задаст для него тип "Код C/C+", что требуется для активации вкладки свойств C/C++. Такая неправильная идентификация остается актуальной и в случае переименования файла с использованием `.cpp`. Чтобы правильно задать тип файла, в **обозревателе решений** щелкните файл правой кнопкой мыши, выберите **Свойства**, затем установите для параметра **Тип файла** значение **Код C/C++**.

1. Щелкните проект C++ правой кнопкой мыши и выберите **Сборка**, чтобы протестировать конфигурации (для **отладки** и **выпуска**). Файлы *.pyd* находятся в папке **solution** в каталогах **Debug** и **Release**, а не в самой папке проекта C++.

1. Добавьте следующий код в файл *module.cpp* проекта:

    ```cpp
    #include <Windows.h>
    #include <cmath>

    const double e = 2.7182818284590452353602874713527;

    double sinh_impl(double x) {
        return (1 - pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double cosh_impl(double x) {
        return (1 + pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double tanh_impl(double x) {
        return sinh_impl(x) / cosh_impl(x);
    }
    ```

1. Еще раз выполните сборку проекта C++, чтобы убедиться в правильности кода.

1. Если вы еще этого не сделали, повторите предыдущие действия, чтобы создать второй проект с именем superfastcode2 с идентичным содержимым.

## <a name="convert-the-c-projects-to-extensions-for-python"></a>Преобразование проекта C++ в расширения для Python

Чтобы превратить библиотеку DLL на C++ в расширение для Python, сначала нужно изменить экспортированные методы для взаимодействия с типами Python. После этого нужно добавить функцию, экспортирующую модуль, а также определения методов модуля.

В последующих разделах объясняется, как выполнять эти действия с помощью расширений `CPython` и PyBind11.

### <a name="cpython-extensions"></a>Расширения CPython

Дополнительные пояснения к тому, что показано в этом разделе, см. в [справочном руководстве по API Python/C](https://docs.python.org/3/c-api/index.html) и, главным образом, в разделе [Module Objects](https://docs.python.org/3/c-api/module.html) (Модульные объекты) на сайте python.org (не забудьте выбрать вашу версию Python в раскрывающемся списке в правом верхнем углу, чтобы увидеть подходящую документацию).

1. В верхнюю часть *module.cpp* включите *Python.h*:

    ```cpp
    #include <Python.h>
    ```

1. Измените метод `tanh_impl`, чтобы он принимал и возвращал типы Python (`PyObject*`):

    ```cpp
    PyObject* tanh_impl(PyObject* /* unused module reference */, PyObject* o) {
        double x = PyFloat_AsDouble(o);
        double tanh_x = sinh_impl(x) / cosh_impl(x);
        return PyFloat_FromDouble(tanh_x);
    }
    ```

1. Добавьте структуру, определяющую способ представления функции `tanh_impl` C++ для Python:

    ```cpp
    static PyMethodDef superfastcode_methods[] = {
        // The first property is the name exposed to Python, fast_tanh
        // The second is the C++ function with the implementation
        // METH_O means it takes a single PyObject argument
        { "fast_tanh", (PyCFunction)tanh_impl, METH_O, nullptr },

        // Terminate the array with an object containing nulls.
        { nullptr, nullptr, 0, nullptr }
    };
    ```

1. Добавьте структуру, которая определяет модуль так, как вы хотите ссылаться на него в своем коде Python, в частности, при использовании оператора `from...import`. (Сделайте это соответствующим значением в свойствах проекта в разделе **Свойства конфигурации** > **Общие** > **Имя целевого объекта**.) В следующем примере имя модуля superfastcode означает, что `from superfastcode import fast_tanh` можно использовать в Python, так как `fast_tanh` определяется в `superfastcode_methods`. (Внутренние для проекта C++ имена файлов, такие как *module.cpp*, являются несущественными.)

    ```cpp
    static PyModuleDef superfastcode_module = {
        PyModuleDef_HEAD_INIT,
        "superfastcode",                        // Module name to use with Python import statements
        "Provides some functions, but faster",  // Module description
        0,
        superfastcode_methods                   // Structure that defines the methods of the module
    };
    ```

1. Добавьте метод, вызываемый Python при загрузке модуля. Он должен иметь имя `PyInit_<module-name>`, где &lt;module_name&gt; точно соответствует значению свойства **Общие** > **Целевое имя** проекта C++ (то есть соответствует имени файла *.pyd*, созданного проектом).

    ```cpp
    PyMODINIT_FUNC PyInit_superfastcode() {
        return PyModule_Create(&superfastcode_module);
    }
    ```

1. Еще раз выполните сборку проекта C++, чтобы проверить код. Если возникли ошибки, обратитесь к разделу [Устранение проблем](#troubleshooting), расположенному ниже.

### <a name="pybind11"></a>PyBind11

Если вы выполнили действия, описанные в предыдущем разделе, вы наверняка заметили, что использовали много стандартного кода для создания необходимых структур модуля для кода C++. PyBind11 упрощает процесс с помощью макросов в файле заголовка C++, которые достигают того же результата с гораздо меньшим объемом кода. Сведения о концепциях в этом разделе см. в разделе [Основы PyBind11](https://github.com/pybind/pybind11/blob/master/docs/basics.rst) (github.com).

1. Установите PyBind11 с помощью pip: `pip install pybind11` или `py -m pip install pybind11`. (Кроме того, можно выполнить установку с помощью окна "Окружения Python", а затем использовать команду "Открыть в PowerShell" для следующего шага.)

1. В том же терминале выполните `python -m pybind11 --includes` или `py -m pybind11 --includes`. Будет выведен список путей, которые следует добавить в свойство **C/C++**  > **Общие** > **Дополнительные каталоги включаемых файлов** (префикс `-I` (при наличии) будет удален).

1. В верхнюю часть нового файла *module.cpp*, который не содержит изменения из предыдущего раздела, добавьте файл *pybind11.h*:

    ```cpp
    #include <pybind11/pybind11.h>
    ```

1. В нижней части *module.cpp* используйте макрос `PYBIND11_MODULE`, чтобы определить точку входа в функцию C++:

    ```cpp
    namespace py = pybind11;

    PYBIND11_MODULE(superfastcode2, m) {
        m.def("fast_tanh2", &tanh_impl, R"pbdoc(
            Compute a hyperbolic tangent of a single argument expressed in radians.
        )pbdoc");

    #ifdef VERSION_INFO
        m.attr("__version__") = VERSION_INFO;
    #else
        m.attr("__version__") = "dev";
    #endif
    }
    ```

1. Выполните сборку проекта C++, чтобы проверить код. Если возникли ошибки, читайте следующий раздел об устранении неполадок.

### <a name="troubleshooting"></a>Устранение неполадок

Модуль C++ может не компилироваться по следующим причинам:

- Не удается найти *Python.h* (**E1696: не удается открыть исходный файл Python.h** и/или **C1083: не удается открыть включаемый файл Python.h, файл или каталог не существуют**): проверьте, что в свойствах проекта в разделе **C/C++** > **Общие** > **Дополнительные каталоги включаемых файлов** правильно указан путь к папке *include* вашей установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-projects).

- Не удается найти библиотеки Python. Убедитесь, что путь **Компоновщик** > **Общие** > **Дополнительные каталоги библиотек** в свойствах проекта указывает на папку *libs* установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-projects).

- Ошибки компоновщика, связанные с целевой архитектурой. Измените архитектуру целевого проекта C++ в соответствии с вашей установкой Python. Например, если вы хотите использовать в проекте C++ версию **Win32**, но у вас установлена версия Python x64, измените проект C++ для работы с версией **х64**.

## <a name="test-the-code-and-compare-the-results"></a>Тестирование кода и сравнение результатов

Теперь, когда библиотека DLL структурирована как расширения Python, можно ссылаться на них из проекта Python, импортировать модули и использовать их методы.

### <a name="make-the-dll-available-to-python"></a>Предоставление доступа к библиотеке DLL для Python

Предоставить Python доступ к библиотеке DLL можно двумя способами.

Первый метод работает, если проект Python и проект C++ находятся в одном решении. В **обозревателе решений** щелкните правой кнопкой мыши узел **Ссылки** в проекте Python и затем выберите команду **Добавить ссылку**. В открывшемся диалоговом окне перейдите на вкладку **Проекты**, выберите проекты **superfastcode** и **superfastcode2** и нажмите кнопку **OK**.

![Добавление ссылки на проект superfastcode](media/cpp-add-reference.png)

Альтернативный метод, описанный далее, предполагает установку модуля в имеющемся окружении Python и предоставление к нему доступа в других проектах Python. Более полную документацию см. на сайте [проекта **setuptools**](https://setuptools.readthedocs.io/).

1. Создайте в проекте C++ файл с именем *setup.py*, щелкнув проект правой кнопкой мыши и выбрав пункт **Добавить** > **Новый элемент**. Выберите тип файла **Файл C++ (.cpp)**, присвойте файлу имя `setup.py` и щелкните **ОК**. (Присвоение файлу расширения *.py* позволяет Visual Studio распознавать его как файл Python несмотря на использование шаблона файла C++.) Когда файл откроется в редакторе, вставьте в него следующий код в зависимости от метода расширения:

    **Расширения `CPython` (проект superfastcode)** :

    ```python
    from setuptools import setup, Extension

    sfc_module = Extension('superfastcode', sources = ['module.cpp'])

    setup(
        name='superfastcode',
        version='1.0',
        description='Python Package with superfastcode C++ extension',
        ext_modules=[sfc_module]
    )
    ```

    **`PyBind11` (проект superfastcode2):**

    ```python
    from setuptools import setup, Extension
    import pybind11

    cpp_args = ['-std=c++11', '-stdlib=libc++', '-mmacosx-version-min=10.7']

    sfc_module = Extension(
        'superfastcode2',
        sources=['module.cpp'],
        include_dirs=[pybind11.get_include()],
        language='c++',
        extra_compile_args=cpp_args,
        )

    setup(
        name='superfastcode2',
        version='1.0',
        description='Python package with superfastcode2 C++ extension (PyBind11)',
        ext_modules=[sfc_module],
    )
    ```

1. В проекте C++ создайте второй файл с именем *pyproject.toml* и вставьте в него следующий код.

    ```toml
    [build-system]
    requires = ["setuptools", "wheel", "pybind11"]
    build-backend = "setuptools.build_meta"
    ```

1. Чтобы создать расширение, щелкните правой кнопкой мыши вкладку *pyproject.toml* и выберите "Копировать полный путь" (имя *pyproject.toml* будет удалено из пути перед использованием).

1. В Обозревателе решений щелкните правой кнопкой мыши активное окружение Python и выберите пункт *Управление пакетами Python*.

    > [!Tip]
    > Если пакет уже установлен, он появится в списке. Щелкните значок "X", чтобы удалить пакет перед продолжением.

1. Вставьте скопированный путь в поле поиска и удалите `pyproject.toml` в конце. Затем нажмите клавишу ВВОД, чтобы выполнить установку из этого каталога.

    > [!Tip]
    > Если установка завершается сбоем из-за ошибки разрешения, добавьте `--user` и повторите команду.


### <a name="call-the-dll-from-python"></a>Вызов библиотеки DLL из Python

После того как вы предоставили библиотеки DLL для Python, как описано в предыдущем разделе, вы можете вызвать функции `superfastcode.fast_tanh` и `superfastcode2.fast_tanh2` из кода Python и сравнить их эффективность с реализацией Python:

1. Добавьте приведенные ниже строки в файл *.py*, чтобы вызвать методы, экспортированные из библиотек DLL, и отобразить их выходные данные:

    ```python
    from superfastcode import fast_tanh
    test(lambda d: [fast_tanh(x) for x in d], '[fast_tanh(x) for x in d] (CPython C++ extension)')

    from superfastcode2 import fast_tanh2
    test(lambda d: [fast_tanh2(x) for x in d], '[fast_tanh2(x) for x in d] (PyBind11 C++ extension)')
    ```

1. Запустите программу Python (**Отладка** > **Запуск без отладки** или **CTRL**+**F5**) и убедитесь, что подпрограмма C++ выполняется примерно в 5–20 раз быстрее, чем реализация Python. Обычно выводится следующий результат.

    ```output
    Running benchmarks with COUNT = 500000
    [tanh(x) for x in d] (Python implementation) took 0.758 seconds

    [fast_tanh(x) for x in d] (CPython C++ extension) took 0.076 seconds

    [fast_tanh2(x) for x in d] (PyBind11 C++ extension) took 0.204 seconds
    ```

    Если команда **Запуск без отладки недоступна**, в **обозревателе решений** щелкните правой кнопкой мыши проект Python и выберите команду **Назначить запускаемым проектом**.

1. Попробуйте увеличить значение переменной `COUNT`, чтобы разница стала еще очевиднее. Кроме того, **отладочная** сборка модуля C++ выполняется медленнее, чем сборка **выпуска**, так как **отладочная** сборка менее оптимизирована и включает в себя разные проверки ошибок. Вы можете переключаться между этими конфигурациями для сравнения (но не забывайте вернуться и обновить заданные ранее свойства для конфигурации **выпуска**).

В выходных данных вы можете увидеть, что расширение PyBind11 не такое быстрое, как расширение `CPython`, хотя все равно значительно быстрее, чем прямая реализация на языке Python. Это различие в основном связано с тем, что мы использовали вызов `METH_O`, который не поддерживает несколько параметров, имен параметров или аргументов ключевых слов. PyBind11 создает немного более сложный код, чтобы предоставить вызывающим объектам интерфейс в стиле Python, но поскольку тестовый код вызывает функцию 500 000 раз, результаты могут привести к значительному увеличению издержек.

Чтобы сократить издержки, можно переместить цикл `for` в машинный код. При этом для обработки каждого элемента может потребоваться использовать [протокол итератора](https://docs.python.org/c-api/iter.html) (или типа `py::iterable` PyBind11 для [параметра функции](https://pybind11.readthedocs.io/en/stable/advanced/functions.html#python-objects-as-args)). Удаление повторяющихся переходов между Python и C++ является эффективным способом сокращения времени, затрачиваемого на обработку последовательности.

### <a name="troubleshooting"></a>Устранение неполадок

Если при попытке импортировать модуль появляется `ImportError`, скорее всего, это вызвано одной из следующих причин:

* При сборке с помощью ссылки на проект убедитесь, что свойства проекта C++ соответствуют окружению Python, активированному для проекта Python, особенно каталоги включаемых файлов и библиотеки.

* Убедитесь, что выходному файлу задано имя `superfastcode.pyd`. Файл с другим именем или расширением не будет импортирован.

* Если вы установили модуль с помощью файла *setup.py*, убедитесь, что вы выполнили команду *pip* в окружении Python, активированном для вашего проекта Python. В расширении окружения Python в Обозревателе решений должна отображаться запись для `superfastcode`.

## <a name="debug-the-c-code"></a>Отладка кода C++

Visual Studio поддерживает совместную отладку кода на Python и C++. В этом разделе этот процесс рассматривается на примере проекта **superfastcode**. Для проекта **superfastcode2** действия будут аналогичными.

1. Щелкните проект Python правой кнопкой мыши в **обозревателе решений**, выберите **Свойства**, откройте вкладку **Отладка** и выберите **Отладка** > **Разрешить отладку машинного кода**.

    > [!Tip]
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением **Для продолжения нажмите любую клавишу**. Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск** > **Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Этот аргумент переводит интерпретатор Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш **CTRL**+**Z** > **ВВОД** для выхода. (Кроме того, если вы не против изменения кода Python, можно добавить в конец программы операторы `import os` и `os.system("pause")`. Этот код дублирует исходный запрос с паузой.)

1. Чтобы сохранить изменения свойств, выберите пункт меню **Файл** > **Сохранить**.

1. На панели инструментов Visual Studio измените конфигурацию сборки на режим **Отладка**.

    ![Изменение конфигурации сборки на режим "Отладка"](media/cpp-set-debug.png)

1. Так как в отладчике код, как правило, выполняется дольше, может потребоваться уменьшить значение переменной `COUNT` в файле *.py* приблизительно в пять раз (например, вместо `500000` укажите `100000`).

1. В коде C++ установите точку останова в первой строке метода `tanh_impl`, а затем запустите отладчик (**F5** или **Отладка** > **Начать отладку**). При вызове этого кода отладчик останавливается. Если точка останова не сработает, проверьте, выбрана ли конфигурация **отладки** и сохранен ли проект (при запуске отладчика он не сохраняется автоматически).

    ![Остановка на точке останова в коде C++](media/cpp-debugging.png)

1. На этом этапе вы можете пошагово выполнять код на C++, проверять переменные и т. д. Эти возможности подробно описаны в руководстве по [совместной отладке C++ и Python](debugging-mixed-mode-c-cpp-python-in-visual-studio.md).

## <a name="alternative-approaches"></a>Альтернативные подходы

Существуют различные средства для создания расширений Python, как описано в таблице ниже. Первые две записи для `CPython` и `PyBind11` уже обсуждались в этой статье.

| Метод | Vintage | Представители | 
| --- | --- | --- |
| Модули расширений C/C++ для `CPython` | 1991 | Стандартная библиотека | 
| [PyBind11](https://github.com/pybind/pybind11) (рекомендуется для C++) | 2015 |  |
| [Cython](https://cython.org) (рекомендуется для C) | 2007 г. | [gevent](https://www.gevent.org/), [kivy](https://kivy.org/) |
| [HPy](https://hpyproject.org/) | 2019 | |
| [mypyc](https://mypyc.readthedocs.io/) | 2017 | |
| ctypes | 2003 | [oscrypto](https://github.com/wbond/oscrypto) | 
| cffi | 2013 | [cryptography](https://cryptography.io/), [pypy](https://pypy.org/) |
| SWIG | 1996 | [crfsuite](http://www.chokkan.org/software/crfsuite/) | 
| [Boost.Python](https://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html) | 2002 | |
| [cppyy](https://cppyy.readthedocs.io/) | 2017 | |

## <a name="see-also"></a>См. также

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).
