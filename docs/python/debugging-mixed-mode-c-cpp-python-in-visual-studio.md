---
title: Смешанный режим отладки для Python
description: Одновременная отладка кода C++ и Python в Visual Studio, в том числе переход между средами, просмотр значений и оценка выражений.
ms.date: 11/12/2018
ms.topic: how-to
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.custom: seodec18
ms.workload:
- python
- data-science
ms.openlocfilehash: 85118cebfa862a1575762985d41df61ef76b5cc5
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99949328"
---
# <a name="debug-python-and-c-together"></a>Совместная отладка Python и C++

Большинство обычных отладчиков Python поддерживает только отладку кода Python. Однако на практике Python используется совместно с C или C++ в сценариях, для которых требуется высокая производительность или возможность напрямую вызывать API-интерфейсы платформ. (См. пошаговое руководство в статье [Создание расширения C++ для Python](working-with-c-cpp-python-in-visual-studio.md).)

Visual Studio поддерживает встроенные функции отладки в смешанном режиме одновременно для Python и встроенного кода C/C++. Чтобы использовать их, выберите параметр **Собственные средства разработки Python** для рабочей нагрузки **Разработка на Python** в установщике Visual Studio.

> [!Note]
> Смешанный режим отладки не доступен в Инструментах Python для Visual Studio 1.x в Visual Studio 2015 и более ранних версий.

Отладка в смешанном режиме включает следующие компоненты, описанные в этой статье:

- объединенный стек вызовов;
- переход между кодом Python и машинным кодом;
- точки останова в обоих типах кода;
- просмотр представлений Python для объектов во фреймах машинного кода и наоборот;
- Отладка в контексте проекта Python или проекта C++

![Смешанный режим отладки для Python в Visual Studio](media/mixed-mode-debugging.png)

![значок кинокамеры для видео](../install/media/video-icon.png "Посмотрите видео") Общие сведения о создании, тестировании и отладке модулей машинного кода C с помощью Visual Studio см. в видео [Подробный обзор. Создание собственных модулей](https://youtu.be/D9RlT06a1EI) (youtube.com, 9 мин 09 с). Это видео относится как к Visual Studio 2015, так и к Visual Studio 2017.


## <a name="enable-mixed-mode-debugging-in-a-python-project"></a>Включение отладки в смешанном режиме в проекте Python

1. Щелкните проект Python правой кнопкой мыши в **обозревателе решений**, выберите пункт **Свойства**, откройте вкладку **Отладка** и выберите параметр **Включить отладку машинного кода**. Этот параметр включает смешанный режим для всех сеансов отладки.

    ![Включение отладки машинного кода](media/mixed-mode-debugging-enable-native.png)

    > [!Tip]
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением **Для продолжения нажмите любую клавишу**. Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск** > **Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Этот аргумент переводит интерпретатор Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш **CTRL**+**Z** > **ВВОД** для выхода.

1. При присоединении отладчика смешанного режима к существующему процессу (**Отладка** > **Присоединить к процессу**) нажмите кнопку **Выбрать**, чтобы открыть диалоговое окно **Выбор типа кода**. Выберите параметр **Выполнять отладку кода следующих типов**, затем выберите в списке **Машинный код** и **Python**:

    ![Выбор типов кода Python и машинного кода](media/mixed-mode-debugging-code-type.png)

    Параметры типа кода являются постоянными, поэтому, если позже вам понадобится отключить отладку в смешанном режиме при присоединении к другому процессу, очистите тип кода **Python**.

    Можно выбрать другие типы кода в дополнение к **машинному коду** или вместо него. Например, если CPython размещается в управляемом приложении, которое, в свою очередь, использует собственные модули расширения, и необходимо выполнить отладку всех трех компонентов, можно одновременно выбрать **Python**, **Машинный код** и **Управляемый код** для единой отладки, в том числе использования объединенных стеков вызовов и переключения между всеми тремя средами выполнения.

1. Когда вы впервые приступите к отладке в смешанном режиме, может отобразиться диалоговое окно **Необходимые символы Python**. См. статью [Символы для отладки в смешанном режиме](debugging-symbols-for-mixed-mode-c-cpp-python.md). Символы для любой среды Python необходимо установить только один раз. Символы включаются автоматически при установке поддержки Python с помощью Visual Studio Installer (Visual Studio 2017 и более поздних версий).

1. Чтобы использовать при отладке непосредственно стандартный исходный код Python, откройте страницу [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/), скачайте архив для вашей версии и извлеките его в папку. Укажите Visual Studio на конкретные файлы в этой папке при отображении соответствующего запроса.

## <a name="enable-mixed-mode-debugging-in-a-cc-project"></a>Включение отладки в смешанном режиме в проекте C/C++

Visual Studio 2017 (версии 15.5 и более поздних) поддерживает отладку в смешанном режиме из проекта C/C++ (например, при [внедрении Python в другое приложение, как описано на python.org](https://docs.python.org/3/extending/embedding.html)). Чтобы использовать отладку в смешанном режиме, укажите **Отладка Python и машинного кода** в качестве загружаемого отладчика в настройках проекта C/C++.

1. В **обозревателе решений** щелкните проект C/C++ правой кнопкой мыши и выберите пункт **Свойства**.
1. Перейдите на вкладку **Отладка** и в качестве **загружаемого отладчика** выберите **Отладка Python и машинного кода**, после чего нажмите кнопку **ОК**.

    ![Выбор "Отладчика Python и машинного кода" в проекте C/C++](media/mixed-mode-debugging-select-cpp-debugger.png)

> [!Note]
> Если у вас нет возможности выбрать параметр **Отладка Python и в машинном коде**, необходимо сначала установить **собственные средства разработки Python** с помощью Visual Studio Installer. Его можно найти в качестве параметра в рабочей нагрузке разработки Python. Дополнительные сведения см. в статье о [добавлении поддержки Python в Visual Studio на платформе Windows](installing-python-support-in-visual-studio.md).

При использовании этого метода учитывайте, что вы не можете отлаживать само средство запуска *py.exe*, так как оно порождает дочерний процесс *python.exe*, к которому отладчик привязан не будет. Если вы хотите напрямую запускать *python.exe* с аргументами, в свойствах **отладки Python и машинного кода** (см. изображение выше) в параметре **Команда** укажите полный путь к *python.exe*, а затем укажите аргументы в параметре **Аргументы команды**.

### <a name="attaching-the-mixed-mode-debugger"></a>Подключение отладчика смешанного режима

Во всех предыдущих версиях Visual Studio непосредственная отладка в смешанном режиме возможна только при запуске проекта Python в Visual Studio, так как проекты C/C++ используют только отладчик машинного кода. Но вы можете подключить отладчик отдельно.

1. Запустите проект C++ без отладки (выберите **Отладка** > **Запуск без отладки** или нажмите клавиши **CTRL**+**F5**).
1. Выберите **Отладка** > **Присоединение к процессу**. В открывшемся диалоговом окне выберите соответствующий процесс, затем нажмите кнопку **Выбрать**, чтобы открыть диалоговое окно **Выбор типа кода**, в котором можно выбрать **Python**:

    ![Выбор Python в качестве типа отладки при подсоединении отладчика](media/mixed-mode-debugging-attach-type.png)

1. Нажмите **ОК**, чтобы закрыть диалоговое окно, затем нажмите **Присоединить** для запуска отладчика.
1. Может потребоваться добавить соответствующую паузу или задержку в приложение C++, чтобы это приложение не вызывало код Python, отладку которого необходимо выполнить, пока вы не сможете присоединить отладчик.

## <a name="mixed-mode-specific-features"></a>Функции, характерные для смешанного режима

- [Объединенный стек вызовов](#combined-call-stack)
- [переход между кодом Python и машинным кодом;](#step-between-python-and-native-code)
- [Представление значений PyObject в машинном коде](#pyobject-values-view-in-native-code)
- [Представление значений машинного кода в коде Python](#native-values-view-in-python-code)

### <a name="combined-call-stack"></a>Объединенный стек вызовов

В окне **стека вызовов** представлены чередующиеся кадры стеков машинного кода и Python с помеченными переходами.

![Объединенный стек вызовов с отладкой в смешанном режиме](media/mixed-mode-debugging-call-stack.png)

Переходы отображаются в виде **внешнего кода** без указания направления перехода, если задан параметр **Инструменты** > **Параметры** > **Отладка** > **Общие** > **Включить только мой код**.

Если дважды щелкнуть какой-либо кадр вызова, он станет активным и откроется соответствующий исходный код, если это возможно. Если исходный код недоступен, кадр все равно становится активным и можно проверить локальные переменные.

### <a name="step-between-python-and-native-code"></a>переход между кодом Python и машинным кодом;

При использовании команд **Шаг с заходом** (**F11**) или **Шаг с выходом** (**SHIFT**+**F11**) отладчик в смешанном режиме правильно обрабатывает изменения типов кода. Например, когда Python вызывает метод типа, который реализован на языке C, переход с заходом в вызов этого метода останавливается в начале собственной функции, реализующей метод. Аналогичным образом, когда машинный код вызывает функцию API Python, вызывается код Python. Например, шаг с заходом в `PyObject_CallObject` значения функции, которая была изначально определена на языке Python, остановится в начале функции Python. Шаг с заходом из Python в машинный код также поддерживается для функций машинного кода, которые вызываются из Python с помощью модуля [ctypes](https://docs.python.org/3/library/ctypes.html).

### <a name="pyobject-values-view-in-native-code"></a>Представление значений PyObject в машинном коде

Если кадр машинного кода (C или C++) активен, его локальные переменные отображаются в окне **локальных переменных** отладчика. В собственных модулях расширения Python многие из переменных относятся к типу `PyObject` (который является typedef для `_object`) или к другим базовым типам Python (см. список ниже). При отладке в смешанном режиме эти значения представляют дополнительный дочерний узел с меткой **[Представление Python]** . При развертывании этот узел отображает представление переменной Python, как и в случае, когда локальная переменная, которая ссылается на тот же объект, присутствует в кадре Python. Дочерние узлы данного узла можно изменять.

![Представление Python в окне "Локальные"](media/mixed-mode-debugging-python-view.png)

Чтобы отключить эту функцию, щелкните правой кнопкой мыши в любом месте в окне **локальных переменных** и снимите флажок **Python** > **Показать узлы представлений Python**:

![Включение представления Python в окне "Локальные"](media/mixed-mode-debugging-enable-python-view.png)

Типы C, для которых отображаются узлы **представления Python** (если включено):

- `PyObject`
- `PyVarObject`
- `PyTypeObject`
- `PyByteArrayObject`
- `PyBytesObject`
- `PyTupleObject`
- `PyListObject`
- `PyDictObject`
- `PySetObject`
- `PyIntObject`
- `PyLongObject`
- `PyFloatObject`
- `PyStringObject`
- `PyUnicodeObject`

Для типов, которые вы создаете самостоятельно, **представление Python** не отображается автоматически. При создании расширений для Python 3.x обычно это не проблема, так как любой объект в конечном итоге имеет поле `ob_base` одного из типов, перечисленных выше, вследствие чего отображается **представление Python**.

Для Python 2.x каждый тип объектов обычно объявляет заголовок как коллекцию встроенных полей. При этом отсутствует связь между создаваемыми пользовательскими типами и `PyObject` на уровне системы типов в коде C или C++. Чтобы включить узлы **представления Python** для таких пользовательских типов, измените файл *PythonDkm.natvis* в [каталоге установки инструментов Python](installing-python-support-in-visual-studio.md#install-locations) и добавьте другой элемент в код XML для структуры C или класса C++.

В качестве альтернативного (и лучшего) варианта можно следовать [PEP 3123](https://www.python.org/dev/peps/pep-3123/) и использовать явное поле `PyObject ob_base;` вместо `PyObject_HEAD`, хотя это может привести к проблемам с обратной совместимостью.

### <a name="native-values-view-in-python-code"></a>Представление значений машинного кода в коде Python

Как и в предыдущем разделе, можно включить **представление C++** для значений машинного кода в окне **локальных переменных** при активном кадре Python. Эта функция отключена по умолчанию. Чтобы включить ее, щелкните правой кнопкой мыши в окне **локальных значений** и установите флажок **Python** > **Показать узлы представлений C++**.

![Включение представления C++ в окне "Локальные"](media/mixed-mode-debugging-enable-cpp-view.png)

Узел **представления C++** отображает базовую структуру C/C++ для значения, идентичную той, которую вы видите в кадре машинного кода. Например, он отображает экземпляр `_longobject` (для которого `PyLongObject` является определением типа typedef) для длинного целого числа Python и пытается определить типы собственных классов, созданных вручную. Дочерние узлы данного узла можно изменять.

![Представление C++ в окне "Локальные"](media/mixed-mode-debugging-cpp-view.png)

Если дочернее поле объекта имеет тип `PyObject` или один из других поддерживаемых типов, он имеет узел **представления Python** (если включено), что позволяет перемещаться по графам объекта, где ссылки не предоставляются непосредственно в Python.

В отличие от узлов **представления Python**, использующих метаданные объекта Python для определения типа объекта, такого же надежного механизма для **представления C++** не существует. В сущности, для заданного значения Python (для ссылки `PyObject`) невозможно точно определить резервную структуру C/C++. Отладчик смешанного режима пытается угадать этот тип, просматривая различные поля типа объекта (например, на `PyTypeObject` ссылается его поле `ob_type`), которые имеют типы указателей функций. Если один из этих указателей ссылается на функцию, которая может быть разрешена, а функция имеет параметр `self` с типом, более точным, чем `PyObject*`, тогда предполагается, что этот тип является резервным. Например, если `ob_type->tp_init` данного объекта указывает на следующую функцию:

```c
static int FobObject_init(FobObject* self, PyObject* args, PyObject* kwds) {
    return 0;
}
```

То отладчик может правильно предположить, что типом C объекта является `FobObject`. Если исходя из `tp_init` не удается определить тип более точно, отладчик переходит к другим полям. Если не удается определить тип на основе любого из этих полей, узел **представления C++** представляет объект как экземпляр `PyObject`.

Чтобы всегда получать полезное представление пользовательских типов, рекомендуется зарегистрировать по меньшей мере одну специальную функцию при регистрации типа и использовать строго типизированный параметр `self`. Большинство типов соответствует этому требованию естественным образом. Если это не так, для этой цели обычно лучше всего использовать запись `tp_init`. Фиктивная реализация `tp_init` для типа, которая присутствует только для того, чтобы определить тип отладки, сразу же возвращает ноль, как в приведенном выше примере.

## <a name="differences-from-standard-python-debugging"></a>Отличия от стандартной отладки Python

Отладчик смешанного режима отличается от [стандартного отладчика Python](debugging-python-in-visual-studio.md) тем, что в нем представлены некоторые дополнительные функции, но отсутствуют определенные возможности, связанные с Python.

- Неподдерживаемые функции: условные точки останова, **интерактивное окно отладки** и удаленная отладка между различными платформами.
- Окно **интерпретации**: доступно, но с ограниченным набором функциональных возможностей, включая все перечисленные здесь ограничения.
- Поддерживаемые версии Python: только CPython 2.7 и 3.3+.
- Оболочка Visual Studio. При использовании Python с оболочкой Visual Studio (например, при выполнении установки с помощью интегрированного средства установки) в Visual Studio не откроются проекты C++, а редактирование файлов C++ будет ограничено возможностями простого текстового редактора. В оболочке полностью поддерживается отладка C/C++ и отладка в смешанном режиме, что позволяет работать с исходным кодом, переходить к машинному коду и вычислять выражения C++ в окнах отладчика.
- Просмотр и развертывание объектов: при просмотре объектов Python в окнах **локальных** и **контрольных значений** отладчика смешанного режима будет отображаться только структура объектов. Свойства не вычисляются автоматически, и вычисляемые атрибуты не отображаются. Для коллекций будут отображаться только элементы встроенных типов (`tuple`, `list`, `dict`, `set`). Пользовательские коллекции не визуализируются в виде коллекций, если они наследуются от коллекции встроенного типа.
- Вычисление выражений: см. сведения ниже.

### <a name="expression-evaluation"></a>Вычисление выражения

Стандартный отладчик Python позволяет вычислять произвольные выражения Python в окнах **контрольных значений** и **интерпретации** отладчика при приостановке отладки в любой точке кода, если она не заблокирована с помощью операции ввода-вывода или другого аналогичного системного вызова. В смешанном режиме отладки произвольные выражения можно вычислить только при остановке в коде Python после точки останова или при шаге с заходом в код. Выражения можно вычислить только в потоке, где были выполнены вышеуказанные операции.

При остановке в машинном коде или в коде Python, где вышеуказанные условия не применяются (например, после выполнения шага с выходом или в другом потоке), вычисление выражений ограничено доступом к локальным и глобальным переменным в рамках текущего выбранного кадра, а также доступом к их полям и индексированию коллекций встроенных типов с литералами. Например, следующее выражение может вычисляться в любом контексте (при условии, что все идентификаторы ссылаются на существующие переменные и поля соответствующих типов).

```python
foo.bar[0].baz['key']
```

Отладчик смешанного режима разрешает такие выражения по-разному. Все операции доступа к элементам ищут только поля, которые непосредственно принадлежат объекту (например, запись в его `__dict__` или `__slots__` либо поле собственной структуры, которое предоставляется Python с помощью `tp_members`), и игнорируют методы `__getattr__`, `__getattribute__` или логику дескриптора. Аналогичным образом все операции индексирования игнорируют `__getitem__` и получают доступ к внутренним структурам данных коллекций напрямую.

Для обеспечения согласованности такая схема разрешения используется для всех выражений, которые соответствуют ограничениям вычисления выражений вне зависимости от того, разрешены ли произвольные выражения в текущей точке остановки. Чтобы обеспечить правильную семантику Python, когда доступен полнофункциональный вычислитель, заключите выражение в скобки.

```python
(foo.bar[0].baz['key'])
```
