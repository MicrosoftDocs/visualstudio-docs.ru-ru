---
title: Классы проектирования C++ в конструкторе классов
description: Сведения о классах C++ и о том, как они поддерживаются и могут иметь несколько отношений наследования в конструкторе классов.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- vs.classdesigner.inheritancelinelabel
helpviewer_keywords:
- Class Designer [Visual Studio], classes
ms.assetid: 75e56f8c-11ef-42a3-b7ec-3d2cf25c581b
author: TerryGLee
ms.author: tglee
manager: jmartens
ms.workload:
- cplusplus
ms.openlocfilehash: e1a1e075d2ac8d06320c46f8d2bb86992814ae24
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99963371"
---
# <a name="c-classes-in-class-designer"></a>Классы проектирования C++ в конструкторе классов

**Конструктор классов** поддерживает классы C++ и визуализирует собственные классы C++ так же, как фигуры классов Visual Basic и C#. Отличие состоит в том, что классы C++ могут обладать отношениями множественного наследования. Фигуру класса можно развернуть, чтобы отобразить дополнительные поля и методы класса, а также свернуть в целях экономии места.

> [!NOTE]
> **Конструктор классов** не поддерживает объединения (это особый тип класса, в котором объем выделяемой памяти равен размеру самого большого элемента данных объединения).

## <a name="simple-inheritance"></a>Простое наследование

Если перетащить на схему сразу несколько классов, между которыми есть отношение наследования, они будут соединены стрелкой. Стрелка указывает в направлении базового класса. Например, если на схеме классов отображаются следующие классы, они будут соединены стрелкой, которая будет указывать от класса B на класс A:

```cpp
class A {};
class B : A {};
```

Также можно перетащить на схему только класс B, щелкнуть правой кнопкой мыши его фигуру, а затем выбрать команду **Показать базовые классы**. В этом случае будет показан базовый класс A.

## <a name="multiple-inheritance"></a>Множественное наследование

**Конструктор классов** поддерживает наглядное представление отношений множественного наследования. *Множественное наследование* используется, если у производного класса есть атрибуты более чем одного базового класса. Ниже приведен пример множественного наследования:

```cpp
class Bird {};
class Swimmer {};
class Penguin : public Bird, public Swimmer {};
```

Если перетащить на схему сразу несколько классов, между которыми есть отношение множественного наследования, они будут соединены стрелкой. Стрелка указывает в направлении базовых классов.

Чтобы просмотреть классы, которые являются базовыми для выбранного, щелкните правой кнопкой мыши фигуру класса и выберите **Показать базовые классы**.

> [!NOTE]
> Команда **Показать производные классы** в коде C++ не поддерживается. Чтобы просмотреть производные классы, перейдите в **представление классов**, разверните узел типа, затем разверните вложенную папку **Производные типы** и перетащите нужные типы на диаграмму классов.

Дополнительные сведения о множественном наследовании классов см. в разделах [Множественное наследование](/previous-versions/6td5yws2(v=vs.140)) и [Несколько базовых классов](/cpp/cpp/multiple-base-classes).

## <a name="abstract-classes"></a>Абстрактные классы

**Конструктор классов** поддерживает абстрактные классы (также называются "абстрактными базовыми классами"). Для этих классов не создаются экземпляры, но от них могут наследоваться другие классы. Используя пример из раздела "Множественное наследование" этого документа, вы можете создавать экземпляры класса `Bird` в виде отдельных объектов, как показано ниже:

```cpp
int main()
{
   Bird sparrow;
   Bird crow;
   Bird eagle;
}
```

Тем не менее вы не можете создавать экземпляры класса `Swimmer` в виде отдельных объектов. При этом вы можете создавать на его основе производные классы, например `Penguin`, `Whale` и `Fish`. В этом случае можно объявить `Swimmer` как абстрактный базовый класс.

Чтобы объявить класс как абстрактный, используйте ключевое слово `abstract`. Элементы, помеченные как абстрактные или включенные в абстрактный класс, являются виртуальными и должны быть реализованы классами, производными от абстрактного класса.

```cpp
class Swimmer abstract
{
   virtual void swim();
   void dive();
};
```

Также можно объявить класс как абстрактный, включив по крайней мере одну чисто виртуальную функцию:

```cpp
class Swimmer
{
   virtual void swim() = 0;
   void dive();
};
```

При выводе этих объявлений на схеме классов имена класса `Swimmer` и его чисто виртуальной функции `swim` отображаются курсивом на фигуре абстрактного класса. Кроме того, будет показана надпись **Абстрактный класс**. Обратите внимание, что фигуры типа абстрактного класса аналогичны обычным классам, но их границы показаны пунктирной линией.

В классе, производном от абстрактного базового класса, необходимо переопределить каждую чисто виртуальную функцию в базовом классе. В противном случае создать экземпляр производного класса нельзя. Например, если необходимо наследовать класс `Fish` от класса `Swimmer`, в классе `Fish` необходимо переопределить метод `swim`:

```cpp
class Fish : public Swimmer
{
   void swim(int speed);
};

int main()
{
   Fish guppy;
}
```

При отображении данного кода на диаграмме классов **конструктор классов** проводит линию наследования от класса `Fish` к классу `Swimmer`.

## <a name="anonymous-classes"></a>Анонимные классы

**Конструктор классов** поддерживает анонимные классы. *Типы анонимных классов* объявляются без идентификатора. Они не могут иметь конструктор или деструктор, не могут передаваться в качестве аргументов в функции и не возвращаются в качестве значений из функций. Анонимный класс можно использовать для замены имени класса именем определения типа, как показано в следующем примере:

```cpp
typedef struct
{
    unsigned x;
    unsigned y;
} POINT;
```

Структуры также могут быть анонимными. **Конструктор классов** отображает анонимные классы и структуры таким же образом, как и соответствующие типы. Несмотря на то, что можно объявить и отобразить анонимные классы и структуры, **конструктор классов** не будет использовать указанное имя тега. В этом случае будет использоваться имя, созданное в представлении классов. Класс или структура отображаются в представлении классов и **конструкторе классов** в виде элемента с именем **__unnamed**.

Дополнительные сведения об анонимных классах см. в разделе [Типы анонимных классов](/cpp/cpp/anonymous-class-types).

## <a name="template-classes"></a>Классы шаблона

**Конструктор классов** поддерживает визуализацию классов шаблона. Поддерживаются вложенные объявления. В следующей таблице показаны некоторые типичные объявления.

| Элемент кода | Представление конструктора классов |
| - | - |
| `template <class T>`<br /><br /> `class A {};` | `A<T>`<br /><br /> Класс шаблона |
| `template <class T, class U>`<br /><br /> `class A {};` | `A<T, U>`<br /><br /> Класс шаблона |
| `template <class T, int i>`<br /><br /> `class A {};` | `A<T, i>`<br /><br /> Класс шаблона |
| `template <class T, template <class K> class U>`<br /><br /> `class A {};` | `A<T, U>`<br /><br /> Класс шаблона |

В следующей таблице показаны некоторые примеры частичной специализации.

|Элемент кода|Представление конструктора классов|
|------------------| - |
|`template<class T, class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс шаблона|
|`template<class T>`<br /><br /> `class A<T, T> {};`|`A<T, T>`<br /><br /> Класс шаблона|
|`template <class T>`<br /><br /> `class A<T, int> {};`|`A<T, int>`<br /><br /> Класс шаблона|
|`template <class T1, class T2>`<br /><br /> `class A<T1*, T2*> {};`|`A<T1*, T2*>`<br /><br /> Класс шаблона|

В следующей таблице показаны некоторые примеры наследования в частичной специализации.

|Элемент кода|Представление конструктора классов|
|------------------| - |
|`template <class T, class U>`<br /><br /> `class A {};`<br /><br /> `template <class TC>`<br /><br /> `class A<T, int> {};`<br /><br /> `class B : A<int, float>`<br /><br /> `{};`<br /><br /> `class C : A<int, int>`<br /><br /> `{};`|`A<T, U>`<br /><br /> Класс шаблона<br /><br /> `B`<br /><br /> Class<br /><br /> (указывает на класс A)<br /><br /> `C`<br /><br /> Class<br /><br /> (указывает на класс A)|

В следующей таблице приведены некоторые примеры функций шаблона частичной специализации.

|Элемент кода|Представление конструктора классов|
|------------------| - |
|`class A`<br /><br /> `{`<br /><br /> `template <class T, class U>`<br /><br /> `void func(T a, U b);`<br /><br /> `template <class T>`<br /><br /> `void func(T a, int b);`<br /><br /> `};`|`A`<br /><br /> func\<T, U> (+ 1 перегрузка)|
|`template <class T1>`<br /><br /> `class A {`<br /><br /> `template <class T2>`<br /><br /> `class B {};`<br /><br /> `};`<br /><br /> `template<> template<>`<br /><br /> `class A<type>::B<type> {};`|`A<T1>`<br /><br /> Класс шаблона<br /><br /> `B<T2>`<br /><br /> Класс шаблона<br /><br /> (Класс B содержится в классе A в разделе **Вложенные типы**)|
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `class A : C<int> {};`|`A`<br /><br /> Class<br /><br /> -> C\<int><br /><br /> `C<T>`<br /><br /> Класс шаблона|

В следующей таблице показаны некоторые примеры наследования шаблонов.

|Элемент кода|Представление конструктора классов|
|------------------| - |
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {`<br /><br /> `class B {};`<br /><br /> `}`<br /><br /> `class A : C<int>::B {};`|`A`<br /><br /> Class<br /><br /> ->B<br /><br /> `C<int>`<br /><br /> Class<br /><br /> (Класс B содержится в классе C в разделе **Вложенные типы**)<br /><br /> `C<T>`<br /><br /> Класс шаблона|

В следующей таблице показаны некоторые примеры связей между классами в канонической специализации.

|Элемент кода|Представление конструктора классов|
|------------------| - |
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {};`<br /><br /> `class A : C<int> {};`<br /><br /> `class D : C<float> {};`|`A`<br /><br /> Class<br /><br /> ->C\<int><br /><br /> `C<int>`<br /><br /> Class<br /><br /> `C<T>`<br /><br /> Класс шаблона<br /><br /> `D`<br /><br /> Class<br /><br /> ->C\<float>|
|`class B {`<br /><br /> `template <class T>`<br /><br /> `T min (const T &a, const T &b);`<br /><br /> `};`|`B`<br /><br /> мин \<T>|

## <a name="see-also"></a>См. также раздел

- [Работа с кодом C++](working-with-visual-cpp-code.md)
- [Классы и структуры](/cpp/cpp/classes-and-structs-cpp)
- [Типы анонимных классов](/cpp/cpp/anonymous-class-types)
- [Множественное наследование](/previous-versions/6td5yws2(v=vs.140))
- [Несколько базовых классов](/cpp/cpp/multiple-base-classes)
- [Шаблоны](/cpp/cpp/templates-cpp)