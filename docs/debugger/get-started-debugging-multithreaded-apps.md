---
title: Сведения об отладке многопоточных приложений
description: Отладка с использованием параллельных стеков и параллельных окон контрольных значений в Visual Studio
ms.custom: ''
ms.date: 02/14/2020
ms.topic: how-to
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- multithreaded debugging, tutorial
- tutorials, multithreaded debugging
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: bc5232d616466ec5aa0916d5d1ad9e7bd5b1247c
ms.sourcegitcommit: 5654b7a57a9af111a6f29239212d76086bc745c9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "101684123"
---
# <a name="get-started-debugging-multithreaded-applications-c-visual-basic-c"></a>Начало отладки многопоточных приложений (C#, Visual Basic, C++)

Visual Studio предоставляет несколько средств и элементов пользовательского интерфейса, помогающих в отладке многопоточных приложений. В этом учебнике показано, как использовать маркеры потоков, окно **Параллельные стеки**, окно **Параллельные контрольные значения**, условные точки останова и точки останова с фильтром. В этом учебнике мы познакомимся с функциями Visual Studio для отладки многопоточных приложений.

В этих двух разделах содержатся дополнительные сведения об использовании других средств многопотоковой отладки.

- Чтобы использовать панель инструментов **Место отладки** и окно **Потоки**, см. раздел [Пошаговое руководство. Отладка многопоточных приложений](../debugger/how-to-use-the-threads-window.md).

- Пример, использующий <xref:System.Threading.Tasks.Task> (управляемый код) и среду выполнения с параллелизмом (C++), см. в разделе [Пошаговое руководство. Отладка параллельного приложения](../debugger/walkthrough-debugging-a-parallel-application.md). Для общих советов по отладке, которые относятся к большинству типов многопоточных приложений, ознакомьтесь с этим разделом и с пошаговым руководством.

Сначала вам требуется проект многопоточного приложения. См. пример ниже.

## <a name="create-a-multithreaded-app-project"></a>Создание проекта многопоточного приложения

1. Откройте Visual Studio и создайте новый проект.

   ::: moniker range=">=vs-2019"

   Если окно запуска не открыто, выберите **Файл** > **Окно запуска**.

   На начальном экране выберите **Создать проект**.

   В поле поиска окна **Создание проекта** введите *консоль*. Затем выберите **C#** , **C++** или **Visual Basic** в списке языков и **Windows** в списке платформ. 

   Применив фильтры по языку и платформе, выберите шаблон **Консольное приложение** для .NET Core или С++ и щелкните **Далее**.

   > [!NOTE]
   > Если нужный шаблон проекта отсутствует, перейдите в меню **Сервис** > **Получить средства и компоненты...** , после чего запустится Visual Studio Installer. Выберите рабочую нагрузку **Кроссплатформенная разработка .NET Core** или **Разработка классических приложений на C++** и щелкните **Изменить**.

   В поле **Имя проекта** окна **Настроить новый проект** введите *MyThreadWalkthroughApp*. Затем щелкните **Далее** или **Создать** в зависимости от того, какой вариант доступен.

   Для проекта .NET Core выберите рекомендуемую версию целевой платформы (.NET Core 3.1) или .NET 5 и щелкните **Создать**.

   ::: moniker-end
   ::: moniker range="vs-2017"
   В верхней строке меню последовательно выберите **Файл**  > **Создать**  > **Проект**. В левой области диалогового окна **Создание проекта** выберите следующие элементы.

   - Для приложения C# в разделе **Visual C#** выберите **Рабочий стол Windows**, а затем в средней области выберите **Консольное приложение (.NET Framework)** .
   - Для приложения Visual Basic в разделе **Visual Basic** выберите **Рабочий стол Windows**, а затем в средней области выберите **Консольное приложение (.NET Framework)** .
   - Для приложения C++ в разделе **Visual C++** выберите **Рабочий стол Windows**, а затем выберите **Консольное приложение Windows**.

   Если вы не видите шаблон **Консольное приложение (.NET Framework)** или (для C++) **Консольное приложение**, выберите **Сервис** > **Получить средства и компоненты**, после чего запустится Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений .NET** или **Разработка классических приложений на C++** , а затем нажмите кнопку **Изменить**.

   Введите имя, например *MyThreadWalkthroughApp*, и нажмите **ОК**.

   Нажмите кнопку **ОК**.
   ::: moniker-end

   Появится новый проект консольного приложения. Когда проект будет создан, откроется файл исходного кода. В зависимости от выбранного языка файл исходного кода может называться *Program.cs*, *MyThreadWalkthroughApp.cpp* или *Module1.vb*.

1. Удалите код, который отображается в исходном файле, и замените его соответствующим образцом кода ниже.

    ```csharp
    using System;
    using System.Threading;

    public class ServerClass
    {

        static int count = 0;
        // The method that will be called when the thread is started.
        public void InstanceMethod()
        {
            Console.WriteLine(
                "ServerClass.InstanceMethod is running on another thread.");

            int data = count++;
            // Pause for a moment to provide a delay to make
            // threads more apparent.
            Thread.Sleep(3000);
            Console.WriteLine(
                "The instance method called by the worker thread has ended. " + data);
        }
    }

    public class Simple
    {
        public static void Main()
        {
            for (int i = 0; i < 10; i++)
            {
                CreateThreads();
            }
        }
        public static void CreateThreads()
        {
            ServerClass serverObject = new ServerClass();

            Thread InstanceCaller = new Thread(new ThreadStart(serverObject.InstanceMethod));
            // Start the thread.
            InstanceCaller.Start();

            Console.WriteLine("The Main() thread calls this after "
                + "starting the new InstanceCaller thread.");

        }
    }
    ```

    ```C++
    // #include "pch.h" // Use with pre-compiled header
    #include <thread>
    #include <iostream>
    #include <vector>
    #include <string>

    int count = 0;

    void doSomeWork() {

        std::cout << "The doSomeWork function is running on another thread." << std::endl;
        int data = count++;
        // Pause for a moment to provide a delay to make
        // threads more apparent.
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::string str = std::to_string(data);
        std::cout << "The function called by the worker thread has ended. " + str<< std::endl;
    }

    int main() {
        std::vector<std::thread> threads;

        for (int i = 0; i < 10; ++i) {

            threads.push_back(std::thread(doSomeWork));
            std::cout << "The Main() thread calls this after starting the new thread" << std::endl;
    }

    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
    }
    ```

    ```VB
    Imports System.Threading

    Public Class ServerClass
        ' The method that will be called when the thread is started.
        Public count = 0
        Public Sub InstanceMethod()
            Console.WriteLine(
                    "ServerClass.InstanceMethod is running on another thread.")

            Dim data = count + 1
            ' Pause for a moment to provide a delay to make
            ' threads more apparent.
            Thread.Sleep(3000)
            Console.WriteLine(
                    "The instance method called by the worker thread has ended. " + data)
        End Sub

    End Class

    Public Class Simple

        Public Shared Sub Main()

            Dim ts As New ThreadStarter
            For index = 1 To 10
                ts.CreateThreads()
            Next

        End Sub

    End Class
    Public Class ThreadStarter
        Public Sub CreateThreads()
            Dim serverObject As New ServerClass()

            ' Create the thread object, passing in the
            ' serverObject.InstanceMethod method using a
            ' ThreadStart delegate.
            Dim InstanceCaller As New Thread(AddressOf serverObject.InstanceMethod)

            ' Start the thread.
            InstanceCaller.Start()

            Console.WriteLine("The Main() thread calls this after " _
                        + "starting the new InstanceCaller thread.")

        End Sub
    End Class
    ```

1. В меню **Файл** выберите команду **Сохранить все**.

1. (Только для Visual Basic) В обозревателе решений (справа) щелкните правой кнопкой мыши узел проекта и выберите **Свойства**. На вкладке **Приложение** измените **Объект запуска**, установив значение **Простой**.

## <a name="debug-the-multithreaded-app"></a>Отладка многопоточного приложения

1. В редакторе исходного кода найдите один из следующих фрагментов кода:

    ```csharp
    Thread.Sleep(3000);
    Console.WriteLine();
    ```

    ```C++
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "The function called by the worker thread has ended." << std::endl;
    ```

    ```VB
    Thread.Sleep(3000)
    Console.WriteLine()
    ```

1. Щелкните левой кнопкой мыши в левом поле инструкции `Thread.Sleep` или `std::this_thread::sleep_for`, чтобы вставить новую точку останова.

    Красный кружок в поле означает, что точка останова установлена в этом месте.

2. В меню **Отладка** выберите команду **Начать отладку** (**F5**).

    Visual Studio создаст решение, приложение начнет работать с подключенным отладчиком, а затем остановится в точке останова.

3. В редакторе исходного кода найдите строку, содержащую точку останова.

### <a name="discover-the-thread-marker"></a><a name="ShowThreadsInSource"></a>Обнаружение маркера потока  

1. На панели инструментов отладки нажмите кнопку **Показать потоки в исходном коде** ![Показать потоки в исходном коде](../debugger/media/dbg-multithreaded-show-threads.png "ThreadMarker").

2. Чтобы перейти в отладчике на одну строку кода вперед, нажмите клавишу **F11**.

3. Посмотрите на переплет в левой части окна. В этой строке отображается значок *Маркер потока* ![Маркер потока](../debugger/media/dbg-thread-marker.png "ThreadMarker"), похожий на переплетение двух нитей. маркер потока указывает, что некий поток остановлен в этом месте.

    Маркер потока может быть частично скрыт точкой останова.

4. Наведите указатель мыши на маркер потока. Подсказка сообщает имя и идентификационный номер каждого остановившегося тут потока. В этом случае этим именем, скорее всего, будет `<noname>`.

5. Выберите маркер потока, чтобы просмотреть доступные параметры в контекстном меню.

### <a name="view-the-thread-locations"></a><a name="ParallelStacks"></a>Просмотр расположений потоков

В окне **Параллельные стеки** можно переключаться между представлением потоков и представлением задач (для программирования на основе задач), а также просматривать сведения о стеке вызовов для каждого потока. В этом приложении можно использовать представление "Потоки".

1. Откройте окно **Параллельные стеки**, выбрав **Отладка** > **Windows** > **Параллельные стеки**. Вы увидите примерно следующее. Точная информация будет отличаться в зависимости от текущего расположения каждого потока, оборудования и языка программирования.

    ![Окно "Параллельные стеки"](../debugger/media/dbg-multithreaded-parallel-stacks.png "ParallelStacksWindow")

    В этом примере слева направо отображаются следующие сведения об управляемом коде.

    - Основной поток (слева) остановлен на `Thread.Start`, где точка остановки обозначается значком маркера потока ![Маркер потока](../debugger/media/dbg-thread-marker.png "ThreadMarker").
    - Два потока вошли в `ServerClass.InstanceMethod`, один из которых является текущим потоком (желтая стрелка), а другой поток остановлен в `Thread.Sleep`.
    - Новый поток (справа) также запускается, но останавливается в `ThreadHelper.ThreadStart`.

2. Щелкните правой кнопкой мыши записи в окне **Параллельные стеки**, чтобы просмотреть доступные параметры в контекстном меню.

    Из этих контекстных меню можно выполнять различные действия, но в этом учебнике мы рассмотрим эти сведения в рамках окна **Параллельные контрольные значения** (в следующих разделах).

    > [!NOTE]
    > Чтобы просмотреть список со сведениями о каждом потоке, используйте окно **Потоки**. См. [Пошаговое руководство: Отладка многопоточных приложений](../debugger/how-to-use-the-threads-window.md).

### <a name="set-a-watch-on-a-variable"></a>Установка контрольных значений для переменной

1. Откройте окно **Параллельные контрольные значения**, выбрав **Отладка** > **Windows** > **Параллельные контрольные значения** > **Параллельное контрольное значение 1**.

2. Выберите ячейку, в которой отображается текст `<Add Watch>` (или пустую ячейку заголовка в 4-м столбце), и введите `data`.

    Значения переменной данных для каждого потока отображаются в окне.

3. Выберите ячейку, в которой отображается текст `<Add Watch>` (или пустую ячейку заголовка в 5-м столбце), и введите `count`.

    Значения переменной `count` для каждого потока отображаются в окне. Если вы еще не видите эту информацию, попробуйте нажать клавишу **F11** несколько раз, чтобы продвинуть выполнение потоков в отладчике.

    ![Окно параллельных контрольных значений](../debugger/media/dbg-multithreaded-parallel-watch.png "ParallelWatchWindow")

4. Щелкните правой кнопкой мыши одну из строк в окне, чтобы просмотреть доступные параметры.

### <a name="flag-and-unflag-threads"></a>Установка и снятие отметки для потока
Вы можете помечать важные потоки и пропускать другие потоки.

1. В окне **Параллельные контрольные значения** выберите несколько строк, удерживая клавишу **SHIFT**.

2. Щелкните правой кнопкой и выберите **Пометить**.

    Все выбранные потоки будут помечены. Теперь можно выполнить фильтрацию, чтобы отображались только помеченные потоки.

3. В окне **Параллельные контрольные значения** выберите **Показывать только помеченные потоки** ![Показывать помеченные потоки](../debugger/media/dbg-threads-show-flagged.png "ThreadMarker").

    В списке отображаются только помеченные потоки.

    > [!TIP]
    > Пометив несколько потоков, щелкните правой кнопкой мыши строку кода в редакторе кода и выберите **Запустить помеченные потоки до курсора**. Обязательно выберите код, которого достигнут все потоки. Visual Studio приостанавливает потоки в выбранной строке кода, что упрощает управление порядком выполнения путем [замораживания и размораживания потоков](#bkmk_freeze).

4. Нажмите кнопку **Показывать только помеченные потоки** снова, чтобы вернуться в режим **Показывать все потоки**.

5. Чтобы снять метки с потоков, щелкните правой кнопкой мыши один или несколько помеченных потоков в окне **Параллельные контрольные значения** и выберите **Снять метку**.

### <a name="freeze-and-thaw-thread-execution"></a><a name="bkmk_freeze"></a> Замораживание и размораживание выполнения потоков

> [!TIP]
> Вы можете замораживать и размораживать (приостанавливать и возобновлять) потоки для управления порядком их выполнения. Это поможет устранить проблемы параллелизма, такие как взаимоблокировки и состояния гонки.

1. В окне **Параллельные контрольные значения** со всеми выбранными строками щелкните правой кнопкой мыши и выберите **Заморозить**.

    Во втором столбце для каждой строки отображается значок паузы. Значок паузы указывает, что поток заморожен.

2. Отмените выбор всех остальных строк, выбрав только одну строку.

3. Щелкните правой кнопкой мыши строку и выберите **Разморозить**.

    Значок паузы исчезает из этой строки, указывая, что поток больше не заморожен.

4. Перейдите в редактор кода и нажмите клавишу **F11**. Выполняется только размороженный поток.

    Приложение также может создавать экземпляры некоторых новых потоков. Новые потоки не помечаются и не замораживаются.

### <a name="follow-a-single-thread-with-conditional-breakpoints"></a><a name="bkmk_follow_a_thread"></a> Изучение одного потока с условными точками останова

Иногда полезно изучать выполнение одного потока в отладчике. Для этого можно заморозить остальные потоки, которые вас не интересуют. В некоторых сценариях необходимо изучить один поток, не замораживая остальные, например для воспроизведения определенной ошибки. Чтобы изучить поток, не замораживая другие потоки, избегайте прерывания выполнения в коде остальных потоков. Для этого установите [условную точку останова](../debugger/using-breakpoints.md#BKMK_Specify_a_breakpoint_condition_using_a_code_expression).

Можно задавать точки останова по различным условиям, например имя потока или идентификатор потока. Иногда полезно задать условие по данным, которые уникальны для каждого потока. Это распространенный сценарий отладки, в котором вас больше интересует значение определенных данных, чем конкретный поток.

1. Щелкните правой кнопкой мыши созданную ранее точку останова и выберите пункт **Условия**.

2. В окне **Параметры точки останова** введите `data == 5` для условного выражения.

    ![Условная точка останова](../debugger/media/dbg-multithreaded-conditional-breakpoint.png "ConditionalBreakpoint")

    > [!TIP]
    > Если вы больше заинтересованы в конкретном потоке, используйте для условия имя потока или идентификатор потока. Для этого в окне **Параметры точки останова** выберите **Фильтр**, а не **Условное выражение** и следуйте подсказкам по фильтрации. При перезапуске отладчика идентификаторы потоков меняются, поэтому можно присвоить потокам имена.

3. Закройте окно **Параметры точки останова**.

4. Нажмите кнопку "Перезапуск" ![Перезапуск приложения](../debugger/media/dbg-tour-restart.png "RestartApp"), чтобы перезапустить сеанс отладки.

    Выполнение остановится в том месте, где значение переменной данных равно 5. В окне **Параллельные контрольные значения** найдите желтую стрелку, указывающую текущий контекст отладчика.

5. Теперь можно использовать шаг с обходом (**F10**) или пошаговое выполнение (**F11**) и проследить за выполнением одного потока.

    Если условие точки останова является уникальным для потока и отладчик не может попасть в другие точки останова в других потоках (может потребоваться отключить их), можно использовать шаг с обходом или пошаговое выполнение без переключения на другие потоки.

    > [!NOTE]
    > При продвижении по отладчику будут выполняться все потоки. Однако отладчик не будет прерывать выполнение кода в других потоках, если только один из других потоков не достигнет точки останова.

## <a name="see-also"></a>См. также

- [Отладка многопоточных приложений](../debugger/debug-multithreaded-applications-in-visual-studio.md)
- [Практическое руководство. Переключение на другой поток при отладке](../debugger/how-to-switch-to-another-thread-while-debugging.md)
- [Практическое руководство. Использование окна "Параллельный стек"](../debugger/using-the-parallel-stacks-window.md)
- [Практическое руководство. Использование окна контроля параллельных данных](../debugger/how-to-use-the-parallel-watch-window.md)