---
title: Как диагностировать производительность расширения | Документация Майкрософт
description: Visual Studio уведомляет пользователей о низком расширении. Сведения о том, как вычисляется воздействие на расширение и как может анализироваться локальное воздействие на расширение.
ms.custom: SEO-VS-2020
ms.date: 11/08/2016
ms.topic: how-to
ms.assetid: 46b0a1e3-7e69-47c9-9d8d-a1815d6c3896
author: BertanAygun
ms.author: bertaygu
manager: jmartens
ms.workload:
- bertaygu
ms.openlocfilehash: 05dda944ab2aecd429386e0e4c40646d21e9a3d4
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99966413"
---
# <a name="measuring-extension-impact-in-startup"></a>Измерение влияния расширения при запуске

## <a name="focus-on-extension-performance-in-visual-studio-2017"></a>Сосредоточьтесь на производительности расширения в Visual Studio 2017

В зависимости от отзывов клиентов одна из областей для выпуска Visual Studio 2017 была загружается и производительность загрузки решения. В качестве группы разработчиков Visual Studio мы работаем над улучшением производительности при запуске и загрузке решения. Как правило, наши измерения предполагают, что установленные расширения также могут оказать значительное влияние на эти сценарии.

Чтобы помочь пользователям понять это воздействие, мы добавили в Visual Studio новую функцию для уведомления пользователей о низком расширении. Иногда Visual Studio обнаруживает новое расширение, которое замедляет загрузку или запуск решения. При обнаружении замедления пользователи увидят уведомление в интегрированной среде разработки, указывающем на новое диалоговое окно "Управление производительностью Visual Studio". Это диалоговое окно также может быть открыто меню «Справка» для просмотра ранее обнаруженных расширений.

![Управление производительностью Visual Studio](media/manage-performance.png)

Этот документ предназначен для помощи разработчикам расширений, которые описывают, как вычисляется воздействие на расширение. В этом документе также описывается, как может анализироваться воздействие на расширение локально. Локальное анализ влияния расширения определяет, может ли расширение отображаться как расширение, влияющее на производительность.

> [!NOTE]
> Этот документ посвящен влиянию расширений при запуске и загрузке решения. Расширения также влияют на производительность Visual Studio, когда они приводят к тому, что пользовательский интерфейс перестает отвечать на запросы. Дополнительные сведения по этой теме см. [в разделе как диагностировать задержки пользовательского интерфейса, вызванные расширениями](how-to-diagnose-ui-delays-caused-by-extensions.md).

## <a name="how-extensions-can-impact-startup"></a>Как расширения могут повлиять на запуск

Один из наиболее распространенных способов влияния расширений на производительность при запуске — выбор автоматической загрузки в одном из известных контекстов пользовательского интерфейса, таких как Носолутионексистс или Шеллинитиализед. Эти контексты пользовательского интерфейса активируются во время запуска. Все пакеты, включающие `ProvideAutoLoad` атрибут в их определение с этими контекстами, будут загружены и инициализированы в это время.

При измерении влияния расширения мы в основном сосредоточены на времени, затраченном на эти расширения, которые выбирают автоматическую загрузку в описанных выше контекстах. Измеряемое время включает, но не ограничивается:

* Загрузка сборок расширений для синхронных пакетов
* Время, затраченное в конструкторе класса пакета для синхронных пакетов
* Время, затраченное на метод инициализации пакета (или SetSite) для синхронных пакетов
* Для асинхронных пакетов приведенные выше операции выполняются в фоновом потоке.  Таким образом, операции исключаются из мониторинга.
* Время, затраченное на выполнение любой асинхронной работы во время инициализации пакета для запуска в основном потоке
* Время, затраченное на обработчики событий, конкретная инициализированная оболочкой активация контекста или изменение состояния оболочки зомби
* Начиная с Visual Studio 2017 с обновлением 3, будет также начато наблюдение за временем бездействия вызовов до инициализации оболочки. Длительные операции в бездействующих обработчиках также вызывают немедленную интегрированную среду разработки и вносят вклад в наблюдаемое время запуска пользователем.

Мы добавили множество функций, начиная с Visual Studio 2015. Эти функции помогают устранять необходимость автоматической загрузки пакетов. Эти функции также откладывают необходимость загрузки пакетов в более конкретные случаи. К этим случаям относятся примеры, в которых пользователям было бы более уверенно использовать расширение или уменьшить воздействие на расширение при автоматической загрузке.

Дополнительные сведения об этих функциях можно найти в следующих документах:

[Контексты пользовательского интерфейса на основе правил](how-to-use-rule-based-ui-context-for-visual-studio-extensions.md). многофункциональное ядро на основе правил, основанное на КОНТЕКСТАХ пользовательского интерфейса, позволяет создавать пользовательские контексты на основе типов проектов, разновидностей и атрибутов. Настраиваемые контексты можно использовать для загрузки пакета во время более конкретных сценариев. Эти конкретные сценарии включают присутствие проекта с определенной возможностью вместо запуска. Пользовательские [контексты также позволяют привязывать видимость команды к пользовательскому](visibilityconstraints-element.md) тексту на основе компонентов проекта или других доступных терминов. Эта функция устраняет необходимость загрузки пакета для регистрации обработчика запросов состояния команды.

[Поддержка асинхронных пакетов](how-to-use-asyncpackage-to-load-vspackages-in-the-background.md). новый базовый класс AsyncPackage в Visual Studio 2015 позволяет асинхронно загружать пакеты Visual Studio в фоновом режиме, если Загрузка пакета была запрошена атрибутом автоматической загрузки или асинхронным запросом службы. Эта загрузка в фоновом режиме позволяет обеспечить высокую скорость реагирования интегрированной среды разработки. Интегрированная среда разработки реагирует даже на то время, пока расширение инициализируется в фоновом и критически важных сценариях, таких как загрузка и загрузка решения, не будут затронуты.

[Асинхронные службы](how-to-provide-an-asynchronous-visual-studio-service.md). Благодаря асинхронной поддержке пакетов мы также добавили поддержку асинхронных запросов служб и возможность регистрации асинхронных служб. Более важно, что мы работаем над преобразованием основных служб Visual Studio для поддержки асинхронных запросов, чтобы большая часть работы в асинхронном запросе возникала в фоновых потоках. Скомпонентмодел (узел MEF в Visual Studio) — одна из основных служб, которая теперь поддерживает асинхронный запрос, позволяя расширениям полностью поддерживать асинхронную загрузку.

## <a name="reducing-impact-of-auto-loaded-extensions"></a>Снижение влияния расширений с автоматической загрузкой

Если пакет по-прежнему должен загружаться автоматически при запуске, важно устранить работу, выполненную во время инициализации пакета. Сведение к минимуму работы по инициализации пакетов сокращает вероятность того, что расширение затронет запуск.

Ниже приведены некоторые примеры, которые могут привести к недорогому инициализации пакета.

### <a name="use-of-synchronous-package-load-instead-of-asynchronous-package-load"></a>Использование синхронной загрузки пакетов вместо асинхронной загрузки пакета

Так как синхронные пакеты загружаются в основной поток по умолчанию, мы рекомендуем владельцам расширений, которые имеют автоматические загруженные пакеты, использовать базовый класс асинхронного пакета, как упоминалось ранее. Изменение автоматического загруженного пакета для поддержки асинхронной загрузки также упрощает устранение других проблем, описанных ниже.

### <a name="synchronous-filenetwork-io-requests"></a>Синхронные файловые и сетевые запросы ввода-вывода

В идеале в основном потоке следует избегать любых запросов на операции ввода-вывода в синхронном файле или сети. Их влияние будет зависеть от состояния компьютера и в некоторых случаях может блокироваться в течение длительного периода времени.

Использование асинхронной загрузки пакетов и интерфейсов API асинхронного ввода-вывода должны гарантировать, что инициализация пакета не блокирует основной поток в таких случаях. Пользователи также могут продолжать взаимодействовать с Visual Studio, в то время как запросы ввода-вывода выполняются в фоновом режиме.

### <a name="early-initialization-of-services-components"></a>Раннее инициализация служб, компоненты

Одним из распространенных шаблонов при инициализации пакета является инициализация служб, используемых или предоставленных этим пакетом в пакете `constructor` или `initialize` методе. Хотя это гарантирует, что службы будут готовы к использованию, они также могут добавить ненужные затраты на загрузку пакетов, если эти службы не используются немедленно. Вместо этого такие службы должны быть инициализированы по запросу, чтобы обеспечить минимальную работу при инициализации пакета.

Для глобальных служб, предоставляемых пакетом, можно использовать `AddService` методы, которые принимают функцию для неактивной инициализации службы, только если она запрошена компонентом. Для служб, используемых в пакете, можно использовать Lazy \<T> или асинклази, \<T> чтобы убедиться, что службы инициализированы или запрашиваются при первом использовании.

## <a name="measuring-impact-of-auto-loaded-extensions-using-activity-log"></a>Измерение влияния расширений с автоматической загрузкой с помощью журнала действий

Начиная с Visual Studio 2017 с обновлением 3, журнал действий Visual Studio теперь содержит записи, влияющие на производительность пакетов во время запуска и загрузки решения. Чтобы увидеть эти измерения, необходимо открыть Visual Studio с параметром/log и открыть файл *ActivityLog.xml* .

В журнале действий записи будут находиться в разделе "Управление производительностью Visual Studio" и будут выглядеть, как в следующем примере:

```Component: 3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c, Inclusive Cost: 2008.9381, Exclusive Cost: 2008.9381, Top Level Inclusive Cost: 2008.9381```

В этом примере показано, что пакет с идентификатором GUID "3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c" занял 2008 МС при запуске Visual Studio. Обратите внимание, что Visual Studio учитывает стоимость верхнего уровня в качестве основного номера при вычислении влияния пакета, так как это будет экономия для пользователей при отключении расширения для этого пакета.

## <a name="measuring-impact-of-auto-loaded-extensions-using-perfview"></a>Измерение влияния расширений с автоматической загрузкой с помощью PerfView

Хотя анализ кода может помочь определить пути кода, которые могут замедлить инициализацию пакета, можно также использовать трассировку с помощью таких приложений, как PerfView, чтобы понять влияние загрузки пакета в Visual Studio Startup.

PerfView — это средство трассировки на уровне системы. Это средство поможет понять критические пути в приложении из-за использования ЦП или блокировки системных вызовов. Ниже приведен краткий пример анализа примера расширения с помощью PerfView, доступного в [центре загрузки Майкрософт](https://www.microsoft.com/en-us/download/details.aspx?id=28567).

**Пример кода:**

Этот пример основан на приведенном ниже образце кода, который предназначен для демонстрации некоторых распространенных причин задержки:

```csharp
protected override void Initialize()
{
    // Initialize a class from another assembly as an example
    MakeVsSlowServiceImpl service = new MakeVsSlowServiceImpl();

    // Costly work in main thread involving file IO
    string systemPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
    foreach (string file in Directory.GetFiles(systemPath))
    {
        DateTime creationDate = File.GetCreationTime(file);
    }

    // Costly work after shell is initialized. This callback executes on main thread
    KnownUIContexts.ShellInitializedContext.WhenActivated(() =>
    {
        DoMoreWork();
    });

    // Start async work on background thread
    DoAsyncWork().Forget();
}

private async Task DoAsyncWork()
{
    // Switch to background thread to do expensive work
    await TaskScheduler.Default;
    System.Threading.Thread.Sleep(500);
}

private void DoMoreWork()
{
    // Costly work
    System.Threading.Thread.Sleep(500);
    // Blocking call to an asynchronous work.
    ThreadHelper.JoinableTaskFactory.Run(async () => { await DoAsyncWork(); });
}
```

**Запись трассировки с помощью PerfView:**

После настройки среды Visual Studio с установленным расширением можно записать трассировку запуска, открыв PerfView и открыв диалоговое окно " **Получение** " из меню " **получить** ".

![меню "perfview"](media/perfview-collect-menu.png)

Параметры по умолчанию предоставляют стеки вызовов для использования ЦП, но так как нам интересно время блокировки, необходимо также включить стеки **времени потока** . Когда параметры будут готовы, можно щелкнуть **Start Collection (начать сбор** ) и открыть Visual Studio после начала записи.

Перед остановкой сбора необходимо убедиться, что Visual Studio полностью инициализирована, главное окно является полностью видимым, а если расширение содержит какие-либо элементы пользовательского интерфейса, которые автоматически отображаются, они также видимы. При полной загрузке Visual Studio и инициализации расширения можно отключить запись для анализа трассировки.

**Анализ трассировки с помощью PerfView:**

Когда запись будет завершена, PerfView автоматически откроет параметры трассировки и развертывания.

В этом примере мы в основном заинтересованы в представлении " **стеки времени потока** ", которое можно найти в разделе " **Расширенная группа**". В этом представлении отображается общее время, затраченное на поток методом, включая время ЦП и время блокировки, такие как дисковые операции ввода-вывода или ожидание дескрипторов.

 ![стеки времени потока](media/perfview-thread-time-stacks.png)

 При открытии представления " **стеки времени открытия потока** " необходимо выбрать процесс **devenv** для начала анализа.

PerfView содержит подробные инструкции по чтению стеков времени потока в отдельном меню "Справка" для более подробного анализа. В этом примере мы хотим отфильтровать это представление, включив в него только стеки с именем модуля пакетов и потоком запуска.

1. Задайте для **грауппатс** пустой текст, чтобы удалить все группирования, добавленные по умолчанию.
2. Задайте **инкпатс** , чтобы включить часть имени сборки и потока запуска в дополнение к существующему фильтру процесса. В этом случае он должен быть **devenv; Поток запуска; Макевссловекстенсион**.

Теперь представление будет показывать только затраты, связанные со сборками, связанными с расширением. В этом представлении любое время, указанное в столбце **Inc. (инклюзивная стоимость)** в потоке запуска, связано с нашим отфильтрованным расширением и будет влиять на запуск.

В примере выше некоторые интересные стеки вызовов будут выглядеть следующим образом:

1. Операции ввода-вывода с использованием `System.IO` класса: в то время как Инклюзивные затраты на эти кадры могут оказаться недорогими в трассировке, это может привести к возникновению проблемы, так как скорость ввода-вывода файлов будет отличаться от компьютера к компьютеру.

   ![кадры системного ввода-вывода](media/perfview-system-io-frames.png)

2. Блокирующие вызовы, ожидающие другой асинхронной работы: в данном случае инклюзивное время будет представлять время блокировки основного потока при завершении асинхронной работы.

   ![блокирующие кадры вызова](media/perfview-blocking-call-frames.png)

Одним из других представлений в трассировке, которые будут полезны для определения влияния, будут **стеки загрузки изображения**. Вы можете применить те же фильтры, что и для представления " **стеки времени потока** ", и найти все сборки, загруженные из-за кода, выполненного загружаемым пакетом.

Важно уменьшить количество загруженных сборок внутри процедуры инициализации пакета, так как каждая дополнительная сборка будет затрагивать дополнительный дисковый ввод-вывод, что может существенно замедлить запуск на медленных компьютерах.

## <a name="summary"></a>Сводка

Запуск Visual Studio был одним из областей, по которым мы постоянно получаем отзывы. Наша цель, как было сказано выше, заключается в том, чтобы все пользователи имели согласованный запуск независимо от установленных компонентов и расширений. Мы хотели бы работать с владельцами расширений, чтобы помочь им добиться этой цели. Приведенные выше рекомендации должны быть полезными для понимания того, какие расширения влияют на запуск, и как избежать необходимости автоматической загрузки или асинхронной загрузки, чтобы свести к минимальному влиянию на производительность пользователей.
