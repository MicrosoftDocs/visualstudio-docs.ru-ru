---
title: Общие сведения о протоколе серверного языка | Документация Майкрософт
description: Узнайте, как протокол серверного языка предоставляет полезную платформу для предоставления языковых функций различным средствам.
ms.custom: SEO-VS-2020
ms.date: 11/14/2017
ms.topic: conceptual
ms.assetid: 6a7d93c2-31ea-4bae-8b29-6988a567ddf2
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: 5dd212b5f75679b44175d9b160d3e11d2075d6a5
ms.sourcegitcommit: f2916d8fd296b92cc402597d1d1eecda4f6cccbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105074032"
---
# <a name="language-server-protocol"></a>Протокол языкового сервера

## <a name="what-is-the-language-server-protocol"></a>Что такое протокол языкового сервера?

Поддержка расширенных возможностей редактирования, таких как автозавершение исходного кода или **Переход к определению** для языка программирования в редакторе или интегрированной среде разработки, обычно очень сложна и занимает много времени. Обычно требуется написать модель предметной области (средство проверки, средство синтаксического анализа, средство проверки типов, конструктор и т. д.) на языке программирования редактора или интегрированной среды разработки. Например, подключаемый модуль Eclipse КДТ, который обеспечивает поддержку C/C++ в интегрированной среде разработки Eclipse, написан на языке Java, так как сама интегрированная среда разработки Eclipse написана на Java. При таком подходе это означает реализацию модели предметной области C/C++ в TypeScript для Visual Studioном коде и отдельной модели предметной области в C# для Visual Studio.

Создание моделей предметно-ориентированного языка также гораздо проще, если средство разработки может повторно использовать существующие библиотеки для конкретного языка. Однако эти библиотеки обычно реализуются на языке программирования (например, в C/C++ реализованы хорошие модели доменов C/C++). Интеграция библиотеки C/C++ в редактор, написанный в TypeScript, технически возможна, но не сложна.

### <a name="language-servers"></a>Языковые серверы

Другой подход заключается в том, чтобы запустить библиотеку в собственном процессе и использовать межпроцессное взаимодействие для взаимодействия с ним. Сообщения, отправляемые обратно и назад, формируют протокол. Протокол Language Server (LSP) — это продукт стандартизации обмена сообщениями между средством разработки и процессом серверного языка. Использование языковых серверов или Демонс не является новой или романской идеей. Такие редакторы, как vim и Emacs, сделали это в течение некоторого времени, чтобы обеспечить поддержку семантического автоматического завершения. Целью LSP является упрощение таких видов интеграции и предоставление полезной инфраструктуры для предоставления языковых функций различным средствам.

Наличие общего протокола позволяет интегрировать функции языка программирования в средство разработки с минимальными спокойной, повторно используя существующую реализацию модели предметной области языка. Серверная часть языкового сервера может быть написана на PHP, Python или Java, а пакет LSP позволяет легко интегрироваться в разнообразные средства. Протокол работает на общем уровне абстракции, поэтому средство может предлагать расширенные языковые службы, не требуя полного понимания особенностей базовой модели предметной области.

## <a name="how-work-on-the-lsp-started"></a>Начало работы с LSP

Этот LSP развивается со временем, и сегодня он находится в версии 3,0. Он запускается, когда концепция языкового сервера была выбрана OmniSharp, чтобы предоставить широкие возможности редактирования для C#. Изначально OmniSharp использовал протокол HTTP с полезной нагрузкой JSON и был интегрирован в несколько редакторов, включая [Visual Studio Code](https://code.visualstudio.com).

В то же время корпорация Майкрософт приступила к работе на сервере языка TypeScript, с представлением о поддержке TypeScript в таких редакторах, как Emacs и подтравяной текст. В этой реализации редактор взаимодействует через stdin/stdout с процессом сервера TypeScript и использует полезные данные JSON, которые могут быть вызваны протоколом отладчика V8 для запросов и ответов. Сервер TypeScript интегрирован в подключаемый модуль TypeScript и VS Code для расширенного редактирования TypeScript.

После интеграции двух разных языковых серверов группа VS Code начала изучать протокол общего языка сервера для редакторов и IDE. Общий протокол позволяет поставщику языка создать сервер с одним языком, который может использоваться различными IDE. Потребитель серверного языка должен только один раз реализовать клиентскую сторону протокола. Это приводит к возникновению проблемы Win-Win для поставщика языка и потребителя языка.

Протокол языкового сервера запущен с протоколом, используемым сервером TypeScript, расширяя его с помощью более новых языковых функций, в том VS Code API языка. Протокол поддерживается с помощью JSON-RPC для удаленного вызова из-за его простоты и существующих библиотек.

Группа VS Code затронула протокол, реализуя несколько языковых серверов средство поиска ошибок, которые отвечают на запросы к Lint (Сканировать) файл и возвращают набор обнаруженных предупреждений и ошибок. Целью было Lint файла по мере редактирования пользователем в документе, что означает, что во время сеанса редактора будет много запросов linting. Имеет смысл поддерживать работу сервера, чтобы новый процесс linting не приходился для каждого пользователя. Были реализованы несколько серверов средство поиска ошибок, включая расширения ESLint и TSLint для VS Code. Эти два сервера средство поиска ошибок реализуются в TypeScript и JavaScript и выполняются на Node.js. Они совместно используют библиотеку, реализующую клиент и серверную часть протокола.

## <a name="how-the-lsp-works"></a>Принцип работы LSP

Языковой сервер работает в собственном процессе, а такие средства, как Visual Studio или VS Code, взаимодействуют с сервером, используя языковой протокол через JSON-RPC. Другое преимущество языкового сервера, работающего в выделенном процессе, заключается в том, что избежать проблем с производительностью, связанных с одной моделью процесса. Фактический канал транспорта может быть stdio, сокетами, именованными каналами или узлом IPC, если клиент и сервер написаны на Node.js.

Ниже приведен пример того, как средство и сервер языка взаимодействуют во время сеанса интерактивного редактирования.

![LSP — схема потока](media/lsp-flow-diagram.png)

* **Пользователь открывает файл (называемый документом) в средстве**: средство уведомляет языковой сервер о том, что документ открыт ("TextDocument/дидопен"). С этого момента содержимое документа больше не находится в файловой системе, но сохраняется средством в памяти.

* **Пользователь вносит изменения**: средство уведомляет сервер об изменении документа ("TextDocument/дидчанже"), а семантические сведения о программе обновляются сервером языка. В этом случае языковой сервер анализирует эти сведения и уведомляет средство об обнаруженных ошибках и предупреждениях ("textDocument/Публишдиагностикс").

* **Пользователь выполняет команду "переход к определению" на символ в редакторе**: инструмент отправляет запрос "textDocument/Definition" с двумя параметрами: (1) URI документа и (2) расположение текста, с которого был инициирован запрос "переход к определению" на сервер. Сервер реагирует на URI документа и расположение определения символа внутри документа.

* **Пользователь закрывает документ (файл)**: в средстве отправляется уведомление "TextDocument/дидклосе", информирующее языковой сервер о том, что документ больше не находится в памяти и что текущее содержимое теперь находится в актуальном состоянии в файловой системе.

В этом примере показано, как протокол обменивается данными с языковым сервером на уровне таких функций редактора, как "переход к определению", "найти все ссылки". Типы данных, используемые протоколом, — это редактор или тип данных IDE, как и текущий открытый текстовый документ и позицию курсора. Типы данных не на уровне модели доменного языка программирования, которая обычно предоставляет абстрактные деревья синтаксиса и символы компилятора (например, разрешенные типы, пространства имен,...). Это значительно упрощает протокол.

Теперь давайте более подробно рассмотрим запрос "textDocument/Definition". Ниже приведены полезные данные между клиентским средством и сервером языка для запроса "переход к определению" в документе C++.

Это запрос:

```json
{
    "jsonrpc": "2.0",
    "id" : 1,
    "method": "textDocument/definition",
    "params": {
        "textDocument": {
            "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp"
        },
        "position": {
            "line": 3,
            "character": 12
        }
    }
}
```

Ответ:

```json
{
    "jsonrpc": "2.0",
    "id": "1",
    "result": {
        "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp",
        "range": {
            "start": {
                "line": 0,
                "character": 4
            },
            "end": {
                "line": 0,
                "character": 11
            }
        }
    }
}
```

В ретроспективе описание типов данных на уровне редактора, а не на уровне модели языка программирования, является одной из причин успеха протокола языкового сервера. Гораздо проще стандартизировать универсальный код ресурса (URI) текстового документа или позицию курсора в сравнении с стандартизацией абстрактного синтаксического дерева и символов компилятора на разных языках программирования.

Когда пользователь работает с различными языками, VS Code обычно запускает языковой сервер для каждого языка программирования. В примере ниже показан сеанс, в котором пользователь работает с файлами Java и Sasser.

![Java и Sasser](media/lsp-java-and-sass.png)

### <a name="capabilities"></a>Возможности

Не каждый языковой сервер может поддерживать все функции, определенные Протоколом. Таким образом, клиент и сервер объявляют поддерживаемый набор функций с помощью возможностей. Например, сервер объявляет о том, что он может обслужить запрос "textDocument/Definition", но он может не работать с запросом "Рабочая область или символ". Аналогичным образом клиенты могут сообщать о возможности предоставления уведомлений о сохранении перед сохранением документа, чтобы сервер мог вычислять текстовые изменения для автоматического форматирования измененного документа.

## <a name="integrating-a-language-server"></a>Интеграция языкового сервера

Фактическая интеграция языкового сервера в определенный инструмент не определяется протоколом языкового сервера и остается средством реализации средств. Некоторые средства интегрируют языковые серверы обычным способом, используя расширение, которое может начинаться и взаимодействовать с любым языковым сервером. Другие, например VS Code, создают пользовательское расширение для каждого языкового сервера, чтобы расширение могло предоставлять некоторые пользовательские функции языка.

Для упрощения реализации языковых серверов и клиентов существуют библиотеки или пакеты SDK для клиентских и серверных частей. Эти библиотеки предоставляются для разных языков. Например, существует [клиентский модуль NPM](https://www.npmjs.com/package/vscode-languageclient) для упрощения интеграции языкового сервера в расширение VS Code и другой [модуль NPM Language Server](https://www.npmjs.com/package/vscode-languageserver) для написания языкового сервера с помощью Node.js. Это текущий [список](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) библиотек поддержки.

## <a name="using-the-language-server-protocol-in-visual-studio"></a>Использование протокола языкового сервера в Visual Studio

* [Добавление расширения протокола языкового сервера](adding-an-lsp-extension.md) — сведения об интеграции языкового сервера в Visual Studio.
