---
title: Как пакеты VSPackage добавляют элементы пользовательского интерфейса | Документация Майкрософт
description: Узнайте, как пакеты VSPackage добавляют элементы пользовательского интерфейса, такие как меню, панели инструментов и окна инструментов, в Visual Studio.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- user interfaces, adding elements
- UI element design [Visual Studio SDK], VSPackages
- VSPackages, contributing UI elements
ms.assetid: abc5d9d9-b267-48a1-92ad-75fbf2f4c1b9
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: f1d01c2ed91a5f4aad55c196dfb2e689aeea288a
ms.sourcegitcommit: f2916d8fd296b92cc402597d1d1eecda4f6cccbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105086044"
---
# <a name="how-vspackages-add-user-interface-elements"></a>Как пакеты VSPackage добавляют элементы пользовательского интерфейса
Пакет VSPackage может добавлять элементы пользовательского интерфейса (например, меню, панели инструментов и окна инструментов) в Visual Studio с помощью *vsct* -файла.

Руководства по проектированию для элементов пользовательского интерфейса можно найти в [руководстве пользователя Visual Studio](../../extensibility/ux-guidelines/visual-studio-user-experience-guidelines.md).

## <a name="the-visual-studio-command-table-architecture"></a>Архитектура таблицы команд Visual Studio
Как уже отмечалось, архитектура таблицы команд поддерживает вышеизложенные принципы архитектуры. Ниже приведены принципы абстракции, структуры данных и средства архитектуры командной таблицы.

- Существует три основных вида элементов: меню, команды и группы. Меню могут быть представлены в пользовательском интерфейсе в виде меню, подменю, панелей инструментов или окон инструментов. Команды — это процедуры, которые пользователь может выполнить в интегрированной среде разработки, и они могут быть представлены как пункты меню, кнопки, списки или другие элементы управления. Группы — это контейнеры для меню и команд.

- Каждый элемент определяется определением, описывающим элемент, его приоритетом относительно других элементов, а также флагами, которые изменяют его поведение.

- Каждый элемент имеет размещение, описывающее родительский элемент элемента. Элемент может иметь несколько родителей, чтобы он мог отображаться в нескольких расположениях в пользовательском интерфейсе.

У каждой команды должна быть группа в качестве ее родителя, даже если она является единственным дочерним элементом в этой группе. У каждого стандартного меню также должна быть родительская группа. Панели инструментов и окна инструментов действуют как собственные родителей. Группа может иметь в качестве своего родителя главную строку меню Visual Studio или любое меню, панель инструментов или окно инструментов.

### <a name="how-items-are-defined"></a>Определение элементов
*VSCT* -файл форматируется в формате XML. Он определяет элементы пользовательского интерфейса для пакета и определяет, где эти элементы отображаются в интегрированной среде разработки. Каждому меню, группе или команде в пакете сначала назначается идентификатор GUID и идентификатор в `Symbols` разделе. В оставшейся части *vsct* -файла каждое меню, команда и группа определяются по идентификатору GUID и идентификатору. В следующем примере показан типичный `Symbols` раздел, создаваемый шаблоном пакета Visual Studio при выборе **команды меню** в шаблоне.

```xml
<Symbols>
  <!-- This is the package guid. -->
  <GuidSymbol name="guidMenuTextPkg" value="{b1253bc6-d266-402b-89e7-5e3d3b22c746}" />

  <!-- This is the guid used to group the menu commands together -->
  <GuidSymbol name="guidMenuTextCmdSet" value="{a633d4e4-6c65-4436-a138-1abeba7c9a69}">
    <IDSymbol name="MyMenuGroup" value="0x1020" />
    <IDSymbol name="cmdidMyCommand" value="0x0100" />
  </GuidSymbol>

  <GuidSymbol name="guidImages" value="{53323d9a-972d-4671-bb5b-9e418480922f}">
    <IDSymbol name="bmpPic1" value="1" />
    <IDSymbol name="bmpPic2" value="2" />
    <IDSymbol name="bmpPicSearch" value="3" />
    <IDSymbol name="bmpPicX" value="4" />
    <IDSymbol name="bmpPicArrows" value="5" />
  </GuidSymbol>
</Symbols>
```

Элемент верхнего уровня в `Symbols` разделе является [элементом GuidSymbol](../../extensibility/guidsymbol-element.md). `GuidSymbol` элементы сопоставляют имена с идентификаторами GUID, которые используются интегрированной средой разработки для обнаружения пакетов и их частей компонентов.

> [!NOTE]
> Идентификаторы GUID создаются автоматически с помощью шаблона пакета Visual Studio. Можно также создать уникальный идентификатор GUID, щелкнув **Создать GUID** в меню **Сервис** .

Первый `GuidSymbol` элемент, `guid<PackageName>Pkg` , является идентификатором GUID самого пакета. Это идентификатор GUID, который используется Visual Studio для загрузки пакета. Как правило, у него нет дочерних элементов.

По соглашению меню и команды группируются под вторым элементом, `GuidSymbol` `guid<PackageName>CmdSet` и точечные рисунки находятся под третьим `GuidSymbol` элементом, `guidImages` . Не нужно следовать этому соглашению, но каждое меню, группа, команда и точечный рисунок должны быть дочерними `GuidSymbol` элементами элемента.

Во втором `GuidSymbol` элементе, представляющем набор команд пакета, есть несколько `IDSymbol` элементов. Каждый [элемент IDSymbol](../../extensibility/idsymbol-element.md) сопоставляет имя с числовым значением и может представлять меню, группу или команду, которые являются частью набора команд. `IDSymbol`Элементы в третьем `GuidSymbol` элементе представляют точечные рисунки, которые могут использоваться в качестве значков для команд. Так как пары идентификаторов GUID и ID должны быть уникальными в приложении, ни один из двух дочерних элементов одного `GuidSymbol` элемента не может иметь одинаковое значение.

### <a name="menus-groups-and-commands"></a>Меню, группы и команды
Если меню, группа или команда имеет идентификатор GUID и идентификатор, их можно добавить в интегрированную среду разработки. Каждый элемент пользовательского интерфейса должен иметь следующие особенности:

- `guid`Атрибут, совпадающий с именем `GuidSymbol` элемента, в котором определен элемент пользовательского интерфейса.

- `id`Атрибут, совпадающий с именем связанного `IDSymbol` элемента.

Вместе `guid` `id` атрибуты и составляют *СИГНАТУРУ* элемента пользовательского интерфейса.

- `priority`Атрибут, определяющий размещение элемента пользовательского интерфейса в родительском меню или группе.

- [Родительский элемент](../../extensibility/parent-element.md) , имеющий `guid` `id` атрибуты и, которые определяют сигнатуру родительского меню или группы.

#### <a name="menus"></a>Меню
Каждое меню определяется как [элемент меню](../../extensibility/menu-element.md) в `Menus` разделе. Меню должны иметь `guid` `id` атрибуты,, и `priority` и `Parent` элемент, а также следующие дополнительные атрибуты и дочерние элементы:

- `type`Атрибут, указывающий, должно ли меню отображаться в интегрированной среде разработки как вид меню или как панель инструментов.

- [Элемент strings](../../extensibility/strings-element.md) , который содержит [элемент ButtonText](../../extensibility/buttontext-element.md), указывающий заголовок меню в интегрированной среде разработки, и [элемент CommandName](../../extensibility/commandname-element.md), указывающий имя, которое используется в **командном** окне для доступа к меню.

- Необязательные флаги. [Элемент CommandFlag](../../extensibility/command-flag-element.md) может отображаться в определении меню для изменения его внешнего вида или поведения в интегрированной среде разработки.

`Menu`У каждого элемента должна быть группа в качестве родительского элемента, если это не закрепляемый элемент, такой как панель инструментов. Закрепляемое меню — это собственный родительский элемент. Дополнительные сведения о меню и значениях для `type` атрибута см. в документации по [элементу меню](../../extensibility/menu-element.md) .

В следующем примере показано меню, которое отображается в строке меню Visual Studio рядом с меню **Сервис** .

```xml
<Menu guid="guidTopLevelMenuCmdSet" id="TopLevelMenu" priority="0x700" type="Menu">
  <Parent guid="guidSHLMainMenu" id="IDG_VS_MM_TOOLSADDINS" />
  <Strings>
    <ButtonText>TestMenu</ButtonText>
    <CommandName>TestMenu</CommandName>
  </Strings>
</Menu>
```

#### <a name="groups"></a>Группы
Группа — это элемент, который определен в `Groups` разделе файла *vsct* . Группы — это просто контейнеры. Они не отображаются в интегрированной среде разработки, за исключением разделительной линии в меню. Таким образом, [элемент группы](../../extensibility/group-element.md) определяется только его сигнатурой, приоритетом и родительским элементом.

Группа может иметь меню, другую группу или саму себя в качестве родительской. Однако родительским элементом обычно является меню или панель инструментов. Меню в предыдущем примере является дочерним для `IDG_VS_MM_TOOLSADDINS` группы, а эта группа является дочерней по отношению к строке меню Visual Studio. Группа в следующем примере является дочерним элементом меню в предыдущем примере.

```xml
<Group guid="guidTopLevelMenuCmdSet" id="MyMenuGroup" priority="0x0600">
  <Parent guid="guidTopLevelMenuCmdSet" id="TopLevelMenu"/>
</Group>
```

Поскольку эта группа является частью меню, она обычно содержит команды. Однако он также может содержать другие меню. Таким образом определяются подменю, как показано в следующем примере.

```xml
<Menu guid="guidTopLevelMenuCmdSet" id="SubMenu" priority="0x0100" type="Menu">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup"/>
  <Strings>
    <ButtonText>Sub Menu</ButtonText>
    <CommandName>Sub Menu</CommandName>
  </Strings>
</Menu>
```

#### <a name="commands"></a>Команды
Команда, предоставляемая интегрированной среде разработки, определяется как [элемент Button](../../extensibility/button-element.md) или [элемент Combo](../../extensibility/combo-element.md). Для отображения в меню или на панели инструментов команда должна иметь группу в качестве ее родителя.

##### <a name="buttons"></a>Кнопки
Кнопки определяются в `Buttons` разделе. Любой элемент меню, кнопка или другой элемент, который пользователь щелкает для выполнения одной команды, считается кнопкой. Некоторые типы кнопок также могут включать в себя функции списка. Кнопки имеют те же обязательные и необязательные атрибуты, что и меню, и могут иметь [элемент Icon](../../extensibility/icon-element.md) , УКАЗЫВАЮЩИЙ идентификатор GUID и идентификатор точечного рисунка, представляющего кнопку в интегрированной среде разработки. Дополнительные сведения о кнопках и их атрибутах см. в документации по [элементу Buttons](../../extensibility/buttons-element.md) .

Кнопка в следующем примере является дочерней для группы в предыдущем примере и будет отображаться в интегрированной среде разработки как пункт меню в родительском меню этой группы.

```xml
<Button guid="guidTopLevelMenuCmdSet" id="cmdidTestCommand" priority="0x0100" type="Button">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup" />
  <Icon guid="guidImages" id="bmpPic1" />
  <Strings>
    <CommandName>cmdidTestCommand</CommandName>
    <ButtonText>Test Command</ButtonText>
  </Strings>
</Button>
```

##### <a name="combos"></a>комбос
КомБОС определяются в `Combos` разделе. Каждый `Combo` элемент представляет раскрывающийся список в интегрированной среде разработки. Список может быть или не может быть доступен для записи пользователями, в зависимости от значения `type` атрибута поля со списком. КомБОС имеют те же элементы и поведение, что и кнопки, а также могут иметь следующие дополнительные атрибуты:

- `defaultWidth`Атрибут, задающий ширину в пикселях.

- `idCommandList`Атрибут, указывающий список, содержащий элементы, отображаемые в списке. Список команд должен быть объявлен в том же `GuidSymbol` узле, который содержит поле со списком.

В следующем примере определяется элемент Combo.

```xml
<Combos>
  <Combo guid="guidFirstToolWinCmdSet"
         id="cmdidWindowsMediaFilename"
         priority="0x0100" type="DynamicCombo"
         idCommandList="cmdidWindowsMediaFilenameGetList"
         defaultWidth="130">
    <Parent guid="guidFirstToolWinCmdSet"
            id="ToolbarGroupID" />
    <CommandFlag>IconAndText</CommandFlag>
    <CommandFlag>CommandWellOnly</CommandFlag>
    <CommandFlag>StretchHorizontally</CommandFlag>
    <Strings>
      <CommandName>Filename</CommandName>
      <ButtonText>Enter a Filename</ButtonText>
    </Strings>
  </Combo>
</Combos>
```

##### <a name="bitmaps"></a>Растровые изображения
Команды, которые будут отображаться вместе со значком, должны включать `Icon` элемент, ссылающийся на точечный рисунок, используя его идентификатор GUID и идентификатор. Каждое растровое изображение определяется как [элемент Bitmap](../../extensibility/bitmap-element.md) в `Bitmaps` разделе. Единственными обязательными атрибутами для `Bitmap` определения являются `guid` и `href` , которые указывают на исходный файл. Если исходный файл является полосой ресурсов, также требуется атрибут **уседлист** , чтобы получить список доступных изображений в полоске. Дополнительные сведения см. в документации по [элементу Bitmap](../../extensibility/bitmap-element.md) .

### <a name="parenting"></a>Родительские связи
Следующие правила управляют тем, как элемент может вызывать другой элемент в качестве его родителя.

|Элемент|Определено в этом разделе таблицы команд|Может содержаться (как родительский элемент или как размещение в `CommandPlacements` разделе, так и и то и другое).|Может содержать (называется родительским)|
|-------------| - | - | - |
|Группа|[Элемент Groups](../../extensibility/groups-element.md), интегрированная среда разработки, другие пакеты VSPackage|Меню, группа, сам элемент|Меню, группы и команды|
|Меню|[Элемент Menus](../../extensibility/menus-element.md), интегрированная среда разработки, другие пакеты VSPackage|от 1 до *n* групп|от 0 до *n* групп|
|Панель инструментов|[Элемент Menus](../../extensibility/menus-element.md), интегрированная среда разработки, другие пакеты VSPackage|Сам элемент|от 0 до *n* групп|
|Menu Item|[Элемент Buttons](../../extensibility/buttons-element.md), интегрированная среда разработки, другие пакеты VSPackage|от 1 до *n* групп, сам элемент|от-0 до *n* групп|
|Кнопка|[Элемент Buttons](../../extensibility/buttons-element.md), интегрированная среда разработки, другие пакеты VSPackage|от 1 до *n* групп, сам элемент||
|Комбинированная|[Элемент КомБОС](../../extensibility/combos-element.md), интегрированная среда разработки, другие пакеты VSPackage|от 1 до *n* групп, сам элемент||

### <a name="menu-command-and-group-placement"></a>Размещение меню, команды и группы
Меню, группа или команда могут находиться в нескольких местах в интегрированной среде разработки. Чтобы элемент отображался в нескольких расположениях, он должен быть добавлен в `CommandPlacements` раздел в качестве [элемента CommandPlacement](../../extensibility/commandplacement-element.md). Любое меню, группу или команду можно добавить в качестве размещения команды. Однако панели инструментов не могут располагаться таким образом, так как они не могут появляться в нескольких контекстах, зависящих от контекста.

В командных размещениях есть `guid` `id` атрибуты, и `priority` . Идентификатор GUID и идентификатор должны соответствовать параметрам элемента, который находится в позиции. `priority`Атрибут управляет размещением элемента относительно других элементов. Когда интегрированная среда разработки объединяет два или более элементов с одинаковым приоритетом, их размещение не определено, так как интегрированная среда разработки не гарантирует, что ресурсы пакета считываются в одном и том же порядке при каждом построении пакета.

Если меню или группа отображается в нескольких местах, все дочерние элементы этого меню или группы будут отображаться в каждом экземпляре.

## <a name="command-visibility-and-context"></a>Видимость и контекст команды
При установке нескольких пакетов VSPackage в интегрированной среде разработки могут наблюдаться различные меню, пункты меню и панели инструментов. Чтобы избежать этой проблемы, можно управлять видимостью отдельных элементов пользовательского интерфейса с помощью *ограничений видимости* и флагов команд.

### <a name="visibility-constraints"></a>Ограничения видимости
Ограничение видимости задается как [элемент висибилититем](../../extensibility/visibilityitem-element.md) в `VisibilityConstraints` разделе. Ограничение видимости определяет конкретные контексты пользовательского интерфейса, в которых целевой элемент является видимым. Меню или команда, включенные в этот раздел, видны только в том случае, если один из определенных контекстов активен. Если в этом разделе нет ссылки на меню или команду, они всегда видимы по умолчанию. Этот раздел не применяется к группам.

`VisibilityItem` элементы должны иметь три атрибута, как показано ниже: `guid` и `id` целевого элемента пользовательского интерфейса, и `context` . `context`Атрибут определяет, когда целевой элемент будет видимым, и принимает в качестве его значения любой допустимый контекст пользовательского интерфейса. Константы контекста пользовательского интерфейса для Visual Studio являются членами <xref:Microsoft.VisualStudio.VSConstants> класса. Каждый `VisibilityItem` элемент может принимать только одно значение контекста. Чтобы применить второй контекст, создайте второй элемент, `VisibilityItem` указывающий на тот же элемент, как показано в следующем примере.

```xml
<VisibilityConstraints>
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasSingleProject" />
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasMultipleProjects" />
</VisibilityConstraints>
```

### <a name="command-flags"></a>Флаги команд
Следующие флаги команды могут влиять на видимость меню и команд, к которым они применяются.

`AlwaysCreate` Меню создается, даже если у него нет групп или кнопок.

Допустимо для: `Menu`

`CommandWellOnly` Используйте этот флаг, если команда не отображается в меню верхнего уровня и требуется сделать ее доступной для дополнительной настройки оболочки, например для привязки к ключу. После установки VSPackage пользователь может настроить эти команды, открыв диалоговое окно **Параметры** и изменив расположение команды в категории **Среда клавиатуры** . Не влияет на размещение контекстных меню, панелей инструментов, контроллеров меню или подменю.

Допустимо для: `Button` , `Combo`

`DefaultDisabled` По умолчанию команда отключена, если пакет VSPackage, реализующий команду, не загружен или не был вызван метод QueryStatus.

Допустимо для: `Button` , `Combo`

`DefaultInvisible` По умолчанию команда невидима, если пакет VSPackage, реализующий команду, не загружен или не был вызван метод QueryStatus.

Следует сочетать с `DynamicVisibility` флагом.

Допустимо для: `Button` , `Combo` , `Menu`

`DynamicVisibility` Видимость команды можно изменить с помощью `QueryStatus` метода или идентификатора GUID контекста, включенного в `VisibilityConstraints` раздел.

Применяется к командам, которые отображаются в меню, а не на панелях инструментов. Элементы панели инструментов верхнего уровня могут быть отключены, но не скрыты при `OLECMDF_INVISIBLE` возврате из метода флага `QueryStatus` .

В меню этот флаг также указывает на то, что он должен быть автоматически скрыт, когда его элементы скрыты. Этот флаг обычно назначается подменю, так как меню верхнего уровня уже имеют такое поведение.

Следует сочетать с `DefaultInvisible` флагом.

Допустимо для: `Button` , `Combo` , `Menu`

`NoShowOnMenuController` Если команда, имеющая этот флаг, находится в контроллере меню, команда не отображается в раскрывающемся списке.

Допустимо для: `Button`

Дополнительные сведения о флагах команд см. в документации по [элементу CommandFlag](../../extensibility/command-flag-element.md) .

#### <a name="general-requirements"></a>Общие требования
Перед отображением и включением команды необходимо пройти следующую последовательность тестов:

- Команда располагается правильно.

- `DefaultInvisible`Флаг не установлен.

- Отображается родительское меню или панель инструментов.

- Команда невидима из-за записи контекста в разделе [элемента висибилитиконстраинтс](../../extensibility/visibilityconstraints-element.md) .

- Код VSPackage, реализующий <xref:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget> интерфейс, отображает и включает команду. Код интерфейса не перехватывается и не обработано.

- Когда пользователь щелкает команду, он подлежит процедуре, описанной в разделе [алгоритм маршрутизации](../../extensibility/internals/command-routing-algorithm.md).

## <a name="call-pre-defined-commands"></a>Вызвать предварительно определенные команды
[Элемент уседкоммандс](../../extensibility/usedcommands-element.md) позволяет VSPackage получать доступ к командам, предоставляемым другими пакетами VSPackage или интегрированной средой разработки. Для этого создайте [элемент уседкомманд](../../extensibility/usedcommand-element.md) с идентификатором GUID и идентификатором используемой команды. Это гарантирует, что команда будет загружена Visual Studio, даже если она не является частью текущей конфигурации Visual Studio. Дополнительные сведения см. в разделе [элемент уседкомманд](../../extensibility/usedcommand-element.md).

## <a name="interface-element-appearance"></a>Внешний вид элемента интерфейса
Ниже приведены рекомендации по выбору и размещению элементов команды.

- [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)] предлагает множество элементов пользовательского интерфейса, которые отображаются по-разному в зависимости от размещения.

- Элемент пользовательского интерфейса, определенный с помощью `DefaultInvisible` флага, не будет отображаться в интегрированной среде разработки, если он либо не отображается его реализацией VSPackage <xref:EnvDTE.IDTCommandTarget.QueryStatus%2A> , либо не связан с определенным КОНТЕКСТОМ пользовательского интерфейса в `VisibilityConstraints` разделе.

- Даже успешно размещенная команда может не отображаться. Это обусловлено тем, что интегрированная среда разработки автоматически скрывает или отображает некоторые команды в зависимости от интерфейсов, реализованных пакетом VSPackage (или не имеющий). Например, реализация некоторых интерфейсов сборки VSPackage приводит к автоматическому отображению пунктов меню, связанных с построением.

- Применение `CommandWellOnly` флага в определении элемента пользовательского интерфейса означает, что команду можно добавить только по настройке.

- Команды могут быть доступны только в определенных контекстах пользовательского интерфейса, например, только когда диалоговое окно отображается, когда интегрированная среда разработки находится в режиме конструктора.

- Чтобы некоторые элементы пользовательского интерфейса отображались в интегрированной среде разработки, необходимо реализовать один или несколько интерфейсов или написать некоторый код.

## <a name="see-also"></a>См. также
- [Расширение меню и команд](../../extensibility/extending-menus-and-commands.md)
