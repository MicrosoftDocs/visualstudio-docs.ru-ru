---
title: Создание закодированного теста пользовательского интерфейса
description: Сведения о том, как использовать закодированный тест пользовательского интерфейса для приложения Windows Presentation Framework и как просматривать решения для тестов с определением времени, когда возникают проблемы, и рефакторингом элементов управления.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
author: mikejo5000
ms.openlocfilehash: b2c14869fa8e4a14a209f8fe5ad440d3ae0e569b
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99967960"
---
# <a name="walkthrough-create-edit-and-maintain-a-coded-ui-test"></a>Пошаговое руководство. Создание, изменение и поддержка закодированного теста пользовательского интерфейса

В этом пошаговом руководстве рассматривается создание, изменение и обслуживание закодированных тестов пользовательского интерфейса для проверки приложения Windows Presentation Framework (WPF). В этом пошаговом руководстве приведены решения для корректировки тестов с проблемами, связанными со временем и рефакторингом элементов управления.

[!INCLUDE [coded-ui-test-deprecation](includes/coded-ui-test-deprecation.md)]

## <a name="create-a-wpf-app"></a>Создание приложения WPF

1. Создайте проект **Приложение WPF (.NET Framework)** и назовите его **SimpleWPFApp**.

     Откроется **Конструктор WPF**, где будет открыто окно MainWindow проекта.

2. Если панель элементов еще не открыта, откройте ее. Откройте меню **Вид** и щелкните **Панель элементов**.

3. В разделе **Все элементы управления WPF** перетащите элементы управления **Кнопка**, **CheckBox** и **ProgressBar** в окно MainWindow в рабочей области конструирования.

4. Выберите элемент управления **Кнопка**. В окне **Свойства** измените значение свойства **Имя** с \<No Name> на button1. Затем измените значение свойства **Содержимое** с "Button" на "Start".

5. Выберите элемент управления **ProgressBar**. В окне **Свойства** измените значение свойства **Имя** с \<No Name> на progressBar1. Затем измените значение свойства **Максимум** с **100** на **10000**.

6. Выберите элемент управления **Checkbox**. В окне **Свойства** измените значение свойства **Имя** с \<No Name> на checkBox1 и очистите свойство **IsEnabled**.

     ![Простое приложение WPF](../test/media/codedui_wpfapp.png)

7. Дважды щелкните элемент управления "Кнопка", чтобы добавить обработчик события щелчка.

     В редакторе кода откроется файл *MainWindow.xmal.cs*, курсор будет установлен на новом методе button1_Click.

8. В начале класса MainWindow добавьте делегат. Этот делегат будет использоваться для индикатора выполнения. Чтобы добавить делегат, добавьте следующий код.

    ```csharp
    public partial class MainWindow : Window
    {
            private delegate void ProgressBarDelegate(System.Windows.DependencyProperty dp, Object value);

        public MainWindow()
        {

            InitializeComponent();
        }
    ```

9. В метод button1_Click добавьте следующий код.

    ```csharp
    private void button1_Click(object sender, RoutedEventArgs e)
    {
        double progress = 0;

        ProgressBarDelegate updatePbDelegate =
            new ProgressBarDelegate(progressBar1.SetValue);

        do
        {
            progress ++;

            Dispatcher.Invoke(updatePbDelegate,
                System.Windows.Threading.DispatcherPriority.Background,
                new object[] { ProgressBar.ValueProperty, progress });
            progressBar1.Value = progress;
        }
        while (progressBar1.Value != progressBar1.Maximum);

        checkBox1.IsEnabled = true;
    }
    ```

10. Сохраните файл.

### <a name="run-the-wpf-app"></a>Запуск приложения WPF

1. В меню **Отладка** выберите **Начать отладку** или нажмите клавишу **F5**.

2. Обратите внимание, что элемент управления флажком отключен. Щелкните **Start**.

     Через несколько секунд индикатор выполнения должен дойти до 100%.

3. Теперь вы можете выбрать элемент управления.

4. Закройте приложение SimpleWPFApp.

## <a name="create-a-shortcut-to-the-wpf-app"></a>Создание ярлыка для приложения WPF

1. Найдите созданное ранее приложение SimpleWPFApp.

2. Создайте на рабочем столе ярлык для приложения SimpleWPFApp. Щелкните правой кнопкой мыши файл *SimpleWPFApp.exe* и выберите команду **Копировать**. Щелкните правой кнопкой мыши на рабочем столе и выберите **Вставить ярлык**.

    > [!TIP]
    > Ярлык облегчает добавление и изменение закодированных тестов пользовательского интерфейса для приложения, так как позволяет быстро запустить приложение.

## <a name="create-a-coded-ui-test-for-simplewpfapp"></a>Создание закодированного теста пользовательского интерфейса для приложения SimpleWPFApp

1. В **обозревателе решений** щелкните решение правой кнопкой мыши и выберите пункты **Добавить** > **Новый проект**.

2. Найдите и выберите шаблон **Проект закодированных тестов пользовательского интерфейса** и продолжайте выполнять процедуру, пока не создадите проект.

   > [!NOTE]
   > Если вы не видите шаблон **Проект закодированного теста пользовательского интерфейса**, необходимо [установить компонент закодированного теста пользовательского интерфейса](../test/use-ui-automation-to-test-your-code.md#install-the-coded-ui-test-component).

     В решение добавляется новый проект закодированных тестов пользовательского интерфейса с именем **CodedUITestProject1**, и отображается диалоговое окно **Формирование кода для кодированного теста пользовательского интерфейса**.

1. Выберите параметр **Записать действия, изменить карту ИП или добавить утверждения** и нажмите кнопку **ОК**.

     Откроется окно **UIMap — построитель кодированных тестов ИП**, а окно Visual Studio свернется.

     Дополнительные сведения о параметрах в этом диалоговом окне см. в статье [Создание закодированных тестов пользовательского интерфейса](../test/use-ui-automation-to-test-your-code.md).

1. Щелкните **Начать запись** в диалоговом окне **UIMap — построитель кодированных тестов ИП**.

     ![Начать запись](../test/media/cuit_builder_record.png)

     Вы можете приостановить запись, например если вы работаете с входящей почтой.

     ![Приостановка записи](../test/media/cuit_.png)

    > [!WARNING]
    > Все действия, выполненные на рабочем столе, будут записаны. Приостановите запись, если вы выполняете действия, которые могут привести к записи конфиденциальных данных.

1. Запустите приложение SimpleWPFApp с помощью ярлыка на рабочем столе.

     Обратите внимание, что, как и ранее, элемент управления флажком отключен.

1. В SimpleWPFApp щелкните **Запуск**.

     Через несколько секунд индикатор выполнения должен дойти до 100%.

1. Установите флажок, который теперь включен.

1. Закройте приложение SimpleWPFApp.

1. В окне **UIMap — построитель кодированных тестов ИП** щелкните **Создать код**.

1. В поле **Имя метода** введите **SimpleAppTest** и щелкните **Добавить и сформировать**. Через несколько секунд закодированный тест пользовательского интерфейса будет сформирован и добавлен в решение.

1. Закройте диалоговое окно **UIMap — построитель кодированных тестов ИП**.

     В редакторе кода откроется файл *CodedUITest1.cs*.

1. Сохраните проект.

### <a name="run-the-test"></a>Выполнение теста

1. В меню **Тест** выберите пункт **Windows**, а затем **Обозреватель тестов**.

2. В меню **Построение** выберите пункт **Построить решение**.

3. В файле *CodedUITest1.cs* найдите метод **CodedUITestMethod**, щелкните его правой кнопкой мыши и выберите **Выполнить тесты** или запустите тест в **обозревателе тестов**.

   Пока выполняется закодированный тест пользовательского интерфейса, открыто приложение SimpleWPFApp. Выполняются шаги, которые вы выполняли в предыдущей процедуре. Однако когда тест попытается установить флажок для элемента управления флажком, в окне **результатов теста** появится сообщение, что тест не пройден. Это происходит потому, что тест пытается установить флажок, но не учитывает, что элемент управления флажком недоступен, пока индикатор выполнения не дойдет до 100 %. Эту и аналогичные проблемы можно решить с помощью различных методов `UITestControl.WaitForControlXXX()`, которые доступны для кодированных тестов пользовательского интерфейса. В следующей процедуре демонстрируется использование метода `WaitForControlEnabled()` для исправления ошибки, в результате которой тест выполнен неудачно. Дополнительные сведения см. в статье [Настройка закодированного теста пользовательского интерфейса таким образом, чтобы во время воспроизведения он дожидался определенных событий](../test/making-coded-ui-tests-wait-for-specific-events-during-playback.md).

## <a name="edit-and-rerun-the-coded-ui-test"></a>Редактирование и повторный запуск закодированного теста пользовательского интерфейса

1. В окне **обозревателя тестов** выберите завершившийся неудачей тест и в разделе **StackTrace** выберите первую ссылку на **UIMap.SimpleAppTest()** .

2. Откроется файл *UIMap.Designer.cs*, где в коде будет выделено место ошибки.

    ```csharp
    // Select 'CheckBox' check box
    uICheckBoxCheckBox.Checked = this.SimpleAppTestParams.UICheckBoxCheckBoxChecked;
    ```

3. Для исправления ошибки можно с помощью метода `WaitForControlEnabled()` сделать так, чтобы закодированный тест пользовательского интерфейса ждал включения элемента управления CheckBox перед переходом к этой строке.

    > [!WARNING]
    > Не изменяйте файл *UIMap.Designer.cs*. Любые изменения кода будут перезаписываться каждый раз при создании кода с помощью **построителя кодированных тестов ИП**. Если требуется изменить записанный метод, скопируйте его в файл *UIMap.cs* и переименуйте. Файл *UIMap.cs* можно использовать для переопределения методов и свойств в файле *UIMapDesigner.cs*. Необходимо удалить ссылку на исходный метод в файле *CodedUITest.cs* и заменить ее именем переименованного метода.

4. В **обозревателе решений** найдите *UIMap.uitest* в проекте с закодированными тестами пользовательского интерфейса.

5. Откройте контекстное меню *UIMap.uitest* и нажмите кнопку **Открыть**.

     Закодированный тест пользовательского интерфейса откроется в редакторе закодированных тестов пользовательского интерфейса. Теперь закодированный тест пользовательского интерфейса можно просматривать и редактировать.

6. В области **Действия пользовательского интерфейса** выберите метод теста (SimpleAppTest), который вы хотите переместить в файл *UIMap.cs* или *UIMap.vb*. Перемещение метода в другой файл позволяет добавить пользовательский код, который не будет перезаписан при повторной компиляции кода теста.

7. На панели инструментов **редактора закодированных тестов пользовательского интерфейса** нажмите кнопку **Переместить код**.

8. Откроется диалоговое окно Microsoft Visual Studio. В нем отобразится предупреждение о том, что метод будет перемещен из файла *UIMap.uitest* в файл *UIMap.cs*, после чего метод нельзя будет изменять в редакторе закодированных тестов пользовательского интерфейса. выберите **Yes** (Да).

     Метод теста удаляется из файла *UIMap.uitest* и перестает отображаться в области "Действия пользовательского интерфейса". Чтобы внести изменения в перемещенный тестовый файл, откройте файл *UIMap.cs* в **обозревателе решений**.

9. На панели инструментов Visual Studio выберите **Сохранить**.

     Изменения метода теста сохраняются в файле *UIMap.Designer*.

    > [!WARNING]
    > После того как метод перемещен, его нельзя редактировать в редакторе закодированных тестов пользовательского интерфейса. Для добавления и обслуживания пользовательского кода следует использовать редактор кода.

10. Переименуйте метод из `SimpleAppTest()` в `ModifiedSimpleAppTest()`.

11. Добавьте в файл следующую инструкцию.

    ```csharp
    using Microsoft.VisualStudio.TestTools.UITesting.WpfControls;
    ```

12. Перед найденной ранее строкой кода с ошибкой добавьте следующий метод `WaitForControlEnabled()`.

    ```csharp
    uICheckBoxCheckBox.WaitForControlEnabled();

    // Select 'CheckBox' check box
    uICheckBoxCheckBox.Checked = this.SimpleAppTestParams.UICheckBoxCheckBoxChecked;
    ```

13. В файле *CodedUITest1.cs* найдите метод **CodedUITestMethod** и закомментируйте его либо переименуйте ссылку на исходный метод SimpleAppTest(), указав в ней новый метод ModifiedSimpleAppTest().

    ```csharp
    [TestMethod]
            public void CodedUITestMethod1()
            {
                // To generate code for this test, select "Generate Code for Coded UI Test" from the shortcut menu and select one of the menu items.
                // For more information on generated code, see http://go.microsoft.com/fwlink/?LinkId=179463
                //this.UIMap.SimpleAppTest();
                this.UIMap.ModifiedSimpleAppTest();
            }
    ```

14. В меню **Построение** выберите **Построить решение**.

15. Щелкните правой кнопкой мыши метод **CodedUITestMethod** и выберите команду **Выполнить тесты**.

16. Теперь закодированный тест пользовательского интерфейса успешно выполнит все этапы тестирования, и в окне **обозревателя тестов** отобразится сообщение **Тест пройден**.

## <a name="refactor-a-control-in-simplewpfapp"></a>Рефакторинг элемента управления в приложении SimpleWPFApp

1. В конструкторе в файле *MainWindow.xaml* выберите элемент управления "Кнопка".

2. В верхней части окна **Свойства** измените значение свойства **Имя** с **button1** на **buttonA**.

3. В меню **Построение** выберите **Построить решение**.

4. В **обозревателе тестов** выполните **CodedUITestMethod1**.

     Тест не был пройден, поскольку закодированный тест пользовательского интерфейса не смог обнаружить кнопку, которая раньше была сопоставлена в UIMap как button1. Таким образом рефакторинг может влиять на закодированные тесты пользовательского интерфейса.

5. В окне **обозревателя тестов** в разделе **StackTrace** щелкните первую ссылку рядом с **UIMpa.ModifiedSimpleAppTest()** .

     Откроется файл *UIMap.cs*. В коде выделено место, где произошла ошибка.

    ```csharp
    // Click 'Start' button
    Mouse.Click(uIStartButton, new Point(27, 10));
    ```

     Обратите внимание, что в строке кода, приведенной ранее в этой процедуре, используется имя `UiStartButton` — имя UIMap до рефакторинга.

     Чтобы исправить ошибку, можно добавить элемент управления, для которого был выполнен рефакторинг, в UIMap с помощью **построителя кодированных тестов ИП**. Можно обновить код теста для использования кода, как показано в следующей процедуре.

## <a name="map-refactored-control-rerun-the-test"></a>Сопоставление элемента управления после рефакторинга и повторный запуск теста

1. В файле *CodedUITest1.cs* в методе **CodedUITestMethod1()** щелкните правой кнопкой мыши, выберите **Сформировать код для кодированного теста пользовательского интерфейса** и щелкните **Использовать построитель закодированных тестов пользовательского интерфейса**.

     Откроется окно **UIMap — построитель кодированных тестов ИП**.

2. В помощью созданного ранее ярлыка на рабочем столе запустите созданное ранее приложение SimpleWPFApp.

3. В окне **UIMap — построитель закодированных тестов пользовательского интерфейса** переместите инструмент в виде перекрестия на кнопку **Пуск** приложения SimpleWPFApp.

     Кнопка **Пуск** обведена голубой рамкой. **Построитель кодированных тестов ИП** обработает данные для выбранного элемента управления и через несколько секунд отобразит его свойства. Обратите внимание, что значением **AutomationUId** является **buttonA**.

4. В окне свойств элемента управления щелкните стрелку в левом верхнем углу, чтобы развернуть карту элементов управления ИП. Обратите внимание, что выбран элемент **UIStartButton1**.

5. На панели инструментов щелкните **Добавить элемент управления на карту элементов управления ИП**.

     Сообщение о состоянии в нижней части окна подтвердит действие следующим сообщением: **Выбранный элемент управления добавлен на карту элементов управления ИП**.

6. В окне **UIMap — построитель кодированных тестов ИП** щелкните **Создать код**.

     Отобразится диалоговое окно **Построитель кодированных тестов ИП — формирование кода** с примечанием о том, что новый метод не требуется и что код будет сформирован только для изменений карты элементов управления ИП.

7. Щелкните **Создать**.

8. Закройте приложение SimpleWPFApp.

9. Закройте диалоговое окно **UIMap — построитель кодированных тестов ИП**.

10. В **обозревателе решений** откройте файл *UIMap.Designer.cs*.

11. В файле *UIMap.Designer.cs* найдите свойство **UIStartButton1**. Обратите внимание, что `SearchProperties` имеет значение `"buttonA"`:

    ```csharp
    public WpfButton UIStartButton1
            {
                get
                {
                    if ((this.mUIStartButton1 == null))
                    {
                        this.mUIStartButton1 = new WpfButton(this);
                        #region Search Criteria
                        this.mUIStartButton1.SearchProperties[WpfButton.PropertyNames.AutomationId] = "buttonA";
                        this.mUIStartButton1.WindowTitles.Add("MainWindow");
                        #endregion
                    }
                    return this.mUIStartButton1;
                }
            }
    ```

     Теперь закодированный тест пользовательского интерфейса можно изменить, чтобы использовать только что сопоставленный элемент управления. Как указано в предыдущей процедуре, если требуется переопределить какие-либо методы или свойства в закодированном тесте пользовательского интерфейса, это нужно делать в файле *UIMap.cs*.

12. В файле *UIMap.cs* добавьте конструктор и задайте свойство `SearchProperties` свойства `UIStartButton`, чтобы использовать свойство `AutomationID` со значением `"buttonA":`.

    ```csharp
    public UIMap()
            {
                this.UIMainWindowWindow.UIStartButton.SearchProperties[WpfButton.PropertyNames.AutomationId] = "buttonA";
            }
    ```

13. В меню **Построение** выберите **Построить решение**.

14. В **обозревателе тестов** выполните **CodedUITestMethod1**.

     Теперь закодированный тест пользовательского интерфейса успешно пройдет все этапы тестирования. В окне **результатов теста** отобразится состояние **Тест пройден**.

## <a name="videos"></a>Видео

![Ссылка на видео](../data-tools/media/playvideo.gif) [Начало работы с закодированными тестами пользовательского интерфейса](https://onedrive.live.com/?id=2DB0E1EFE1C1D3B8%21110&cid=2DB0E1EFE1C1D3B8)

## <a name="faq"></a>ВОПРОСЫ И ОТВЕТЫ

[Вопросы и ответы о закодированных тестах пользовательского интерфейса](https://social.msdn.microsoft.com/Forums/vsautotest/3a74dd2c-cef8-4923-abbf-7a91f489e6c4/faqs)

## <a name="see-also"></a>См. также раздел

- [Использование автоматизации пользовательского интерфейса для тестирования кода](../test/use-ui-automation-to-test-your-code.md)
- [Поддерживаемые конфигурации и платформы для закодированных тестов пользовательского интерфейса и записей действий](../test/supported-configurations-and-platforms-for-coded-ui-tests-and-action-recordings.md)
- [Изменение закодированных тестов пользовательского интерфейса с помощью редактора закодированных тестов пользовательского интерфейса](../test/editing-coded-ui-tests-using-the-coded-ui-test-editor.md)
