---
title: Устранение неполадок с покрытием кода
description: Узнайте, как разрешать ошибочные пустые результаты, когда предполагается, что Visual Studio собирает данные для машинных и управляемых сборок.
ms.custom: SEO-VS-2020
ms.date: 03/31/2020
ms.topic: troubleshooting
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
author: mikejo5000
ms.openlocfilehash: d99dcc3a141bc3734c5c356601d0e1e7474f06a7
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99967973"
---
# <a name="troubleshoot-code-coverage"></a>Устранение неполадок в объеме протестированного кода

Средство анализа объема протестированного кода в Visual Studio выполняет сбор данных для машинных и управляемых сборок (*DLL*- или *EXE*-файлы). Однако в некоторых случаях в окне **результатов объема протестированного кода** отображается ошибка, похожая на ошибку "Созданы пустые результаты: ...". Пустые результаты могут возвращаться по нескольким причинам. В этой статье описывается порядок решения подобных проблем.

## <a name="what-you-should-see"></a>Отображаемые сведения

При выборе команды **Анализ покрытия кода** в меню **Тест** (при условии успешной сборки и тестирования) в окне **Покрытие кода** должен отобразиться список результатов. Разверните элементы, чтобы просмотреть сведения о них.

::: moniker range=">=vs-2019"
![Результаты покрытия кода с цветами](../test/media/vs-2019/codecoverage1.png)
::: moniker-end
::: moniker range="vs-2017"
![Результаты покрытия кода с цветами](../test/media/codecoverage1.png)
::: moniker-end

Дополнительные сведения см. в статье [Использование параметра объема протестированного кода для определения объема протестированного кода](../test/using-code-coverage-to-determine-how-much-code-is-being-tested.md).

## <a name="possible-reasons-for-seeing-no-results-or-old-results"></a>Возможные причины отсутствия результатов или отображения старых результатов

### <a name="do-you-have-the-right-edition-of-visual-studio"></a>Вы используете правильный выпуск Visual Studio?

Вам требуется Visual Studio Enterprise.

### <a name="no-tests-were-executed"></a>Тесты не выполнены

Анализ&mdash;Проверьте окно вывода. В раскрывающемся списке **Показать выходные данные из:** выберите **Тесты**. Проверьте, были ли зарегистрированы какие-либо предупреждения или ошибки.

Объяснение&mdash;Анализ покрытия кода выполняется во время выполнения тестов. Он включает только сборки, загруженные в память во время выполнения тестов. Если ни один из тестов не выполняется, это значит, что нет данных для включения в отчет о покрытии кода.

Решение&mdash;В обозревателе тестов щелкните **Запустить все**, чтобы проверить успешность выполнения тестов. Исправьте все ошибки перед выполнением команды **Анализ покрытия кода**.

### <a name="youre-looking-at-a-previous-result"></a>Отображается предыдущий результат

При изменении и повторном выполнении тестов может по-прежнему отображаться предыдущий результат анализа покрытия кода, включая цветовую разметку предыдущего запуска.

1. Выполните команду **Анализ покрытия кода**.

2. Убедитесь в том, что в окне **Результаты покрытия кода** выбран последний набор результатов.

### <a name="pdb-symbol-files-are-unavailable"></a>Недоступны PDB-файлы (файлы символов)

Анализ&mdash;Откройте предназначенную для компиляции папку (обычно это папка *bin\debug*) и убедитесь в том, что для каждой сборки существует *PDB*-файл в том же каталоге, что и *DLL*- или *EXE*-файл.

Объяснение&mdash;Анализатору объема протестированного кода необходимо, чтобы каждая сборка имела связанный с ней *PDB*-файл, доступный во время тестового запуска. Если *PDB*-файл не существует для определенной сборки, она не будет проанализирована.

*PDB*-файл должен быть создан из той же сборки, что и *DLL*- или *EXE*-файл.

Решение&mdash;Убедитесь в том, что в параметрах сборки указано создание *PDB*-файла. Если *PDB*-файлы не обновляются при сборке проекта, откройте свойства проекта, выберите страницу **Сборка**, щелкните **Дополнительно** и проверьте сведения в поле **Отладочная информация**.

Для проектов на C++ создаваемые PDB-файлы должны иметь полную отладочную информацию. Откройте свойства проекта и убедитесь в том, что для параметра **Компоновщик** > **Отладка** > **Создавать отладочную информацию** выбрано значение **Создать сведения об отладке, оптимизированные для общего доступа и публикации (/DEBUG:FULL)** .

Если *PDB*-файл и *DLL*- или *EXE*-файл находятся в разных местах, скопируйте *PDB*-файл в тот же каталог. Также можно настроить анализатор объема протестированного кода для поиска *PDB*-файлов в другом расположении. См. дополнительные сведения по [настройке анализа объема протестированного кода](../test/customizing-code-coverage-analysis.md).

### <a name="use-an-instrumented-or-optimized-binary"></a>Использование инструментированного или оптимизированного двоичного файла

Анализ&mdash;Определите, была ли выполнена какая-либо форма расширенной оптимизации двоичного файла, например профильная оптимизация, или было ли выполнено инструментирование двоичного файла с помощью средств профилирования, таких как *vsinstr.exe* или *vsperfmon.exe*.

Объяснение&mdash;Если сборка уже была инструментирована или оптимизирована другим средством профилирования, то она не учитывается в анализе покрытия кода. Для таких сборок невозможно выполнить анализ покрытия кода.

Решение&mdash;Отключите оптимизацию и используйте новую сборку.

### <a name="code-is-not-managed-net-or-native-c-code"></a>Неуправляемый код (.NET) или машинный код (C++)

Анализ&mdash;Убедитесь, что выполняются тесты управляемого кода или кода C++.

Объяснение&mdash;Анализ покрытия кода в Visual Studio доступен только для управляемого и машинного кода (C++). При работе со средствами сторонних разработчиков часть кода или весь код может выполняться на другой платформе.

Решение&mdash;Недоступно.

### <a name="assembly-has-been-installed-by-ngen"></a>Сборка установлена с помощью NGen

Анализ&mdash;Убедитесь, что сборка не была загружена из кэша образов в машинном коде.

Объяснение&mdash;Из соображений производительности сборки образов в машинном коде не анализируются. См. дополнительные сведения о [файле Ngen.exe (генераторе образов в машинном коде)](/dotnet/framework/tools/ngen-exe-native-image-generator).

Решение&mdash;Используйте MSIL-версию сборки. Не обрабатывайте ее с помощью NGen.

### <a name="custom-runsettings-file-with-bad-syntax"></a>Пользовательский RUNSETTINGS-файл с неверным синтаксисом

Анализ&mdash;Если используется пользовательский *RUNSETTINGS*-файл, он может содержать синтаксические ошибки. Покрытие кода не выполняется, и либо окно покрытия кода не открывается по завершении тестового запуска, либо в нем отображаются старые результаты.

Объяснение&mdash;Можно выполнить модульные тесты, используя пользовательский *RUNSETTINGS*-файл, чтобы настроить параметры объема протестированного кода. С помощью параметров можно включать или исключать файлы. См. дополнительные сведения по [настройке анализа объема протестированного кода](../test/customizing-code-coverage-analysis.md).

Решение&mdash;Существует два возможных типа ошибок:

- **Ошибка XML**

     Откройте *RUNSETTINGS*-файл в редакторе XML Visual Studio. Найдите ошибки.

- **Ошибка в регулярном выражении**

  Каждая строка в файле представляет собой регулярное выражение. Проверьте каждую строку на наличие ошибок, в частности, следующих:

  - Несоответствующие круглые скобки (...) или круглые скобки без escape-последовательности \\(...\\). Для сопоставления с круглыми скобками в строке поиска необходимо установить для них escape-последовательность. Например, для сопоставления с функцией используйте выражение `.*MyFunction\(double\)`

  - Звездочка или плюс в начале выражения. Для сопоставления с любой строкой символов используйте точку со следующей за ней звездочкой: `.*`

### <a name="custom-runsettings-file-with-incorrect-exclusions"></a>Пользовательский RUNSETTINGS-файл с неверными исключениями

Анализ&mdash;Если используется пользовательский *RUNSETTINGS*-файл, проверьте, что он включает в себя вашу сборку.

Объяснение&mdash;Можно выполнить модульные тесты, используя пользовательский *RUNSETTINGS*-файл, чтобы настроить параметры объема протестированного кода. С помощью параметров можно включать или исключать файлы. См. дополнительные сведения по [настройке анализа объема протестированного кода](../test/customizing-code-coverage-analysis.md).

Решение&mdash;Удалите все узлы `Include` из *RUNSETTINGS*-файла, а затем все узлы `Exclude`. Если это не решит проблему, последовательно верните их обратно.

Убедитесь, что узел DataCollectors определяет покрытие кода. Сравните его с примером в разделе [Настройка анализа объема протестированного кода](../test/customizing-code-coverage-analysis.md).

## <a name="some-code-is-always-shown-as-not-covered"></a>Часть кода всегда отображается как непокрытая

### <a name="initialization-code-in-native-dlls-is-executed-before-instrumentation"></a>Код инициализации в машинных библиотеках DLL выполняется до инструментирования

Анализ&mdash;В статически связанном машинном коде часть функции инициализации **DllMain** и вызываемый ею код иногда отображаются как непокрытые, даже если код выполнен.

Объяснение&mdash;Анализатор покрытия кода вставляет инструментирование в сборку непосредственно перед началом выполнения приложения. В любой сборке, загруженной до этого времени, код инициализации в **DllMain** выполняется сразу после загрузки сборки и до выполнения приложения. Этот код будет отображаться как не протестированный. Обычно это применяется к статически загружаемым сборкам.

Решение&mdash;Нет.

## <a name="see-also"></a>См. также

- [Использование параметра объема протестированного кода для определения объема протестированного кода](../test/using-code-coverage-to-determine-how-much-code-is-being-tested.md)
