---
title: Практическое руководство. Создание модульных тестов для библиотек DLL на C++
description: Сведения о том, как разработать собственную библиотеку DLL на C++ с использованием методологии на основе тестирования. Начните с создания собственного тестового проекта.
ms.custom: SEO-VS-2020
ms.date: 06/13/2019
ms.topic: how-to
ms.author: corob
manager: markl
ms.workload:
- cplusplus
author: corob-msft
ms.openlocfilehash: cfdc580b94760cb0c5160918210ba6c3dd8fa2f6
ms.sourcegitcommit: 4b2b6068846425f6964c1fd867370863fc4993ce
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/12/2021
ms.locfileid: "112042929"
---
# <a name="how-to-write-unit-tests-for-c-dlls"></a>Практическое руководство. Написание модульных тестов для библиотек DLL на C++

В этом пошаговом руководстве описывается разработка библиотеки DLL на неуправляемом C++ с использованием методологии на основе тестирования. Основными шагами являются следующие:

1. [Создайте тестовый проект для машинного кода](#create_test_project). Тестовый проект относится к тому же решению, что и проект библиотеки DLL.

2. [Создание проекта библиотеки DLL](#create_dll_project). В этом пошаговом руководстве создается новая библиотека DLL, но процедура тестирования существующей библиотеки DLL аналогична.

3. [Сделайте функции DLL доступными для тестов](#make_functions_visible).

4. [Итеративно расширяйте тесты](#iterate). Рекомендуется цикл "красный — зеленый — рефакторинг", при котором разработка кода проводится согласно результатам тестов.

5. [Выполните отладку непройденных тестов](#debug). Тесты можно выполнять в режиме отладки.

6. [Выполняйте рефакторинг, оставляя тесты без изменений](#refactor). Рефакторинг означает улучшение структуры кода без изменения его внешнего поведения. Это можно сделать для повышения производительности, расширяемости и удобочитаемости кода. Так как поведение кода должно сохраняться, не изменяйте тесты при проведении рефакторинга. Тесты помогают убедиться в том, что при выполнении рефакторинга не возникнут новые ошибки.

7. [Проверьте охват](using-code-coverage-to-determine-how-much-code-is-being-tested.md). Модульные тесты более полезны, когда они охватывают больше кода. Вы можете узнать, какие части кода использовались тестами.

8. [Изолируйте модули от внешних ресурсов](using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md). Обычно библиотека DLL зависит от других компонентов разрабатываемой системы, таких как другие библиотеки DLL, базы данных или удаленные подсистемы. Полезно тестировать каждый модуль отдельно от его зависимостей. Внешние компоненты могут сделать выполнение тестов медленным. Во время разработки другие компоненты могут быть еще не готовы.

## <a name="create-a-native-unit-test-project"></a><a name="create_test_project"></a> Создание проекта машинного модульного теста

1. В меню **Файл** последовательно выберите пункты **Создать** > **Проект**.

     **Visual Studio 2017 и более ранние версии**. Разверните узлы **Установлено** > **Шаблоны** > **Visual C++**  > **Тест**.
     **Visual Studio 2019**. Задайте **Язык** как C++ и введите "тест" в поле поиска.

     Выберите шаблон **Проект машинного модульного теста** или проект другой установленной платформы. При выборе другого шаблона, например Google Test или Boost.Test, основные принципы сохраняются, хотя могут быть некоторые особенности.

     В этом пошаговом руководстве тестовый проект называется `NativeRooterTest`.

2. В новом проекте изучите файл **unittest1.cpp**.

     ![Проект теста с TEST&#95;CLASS и TEST&#95;METHOD](../test/media/utecpp2.png)

     Обратите внимание на указанные ниже моменты.

    - Каждый тест определяется с использованием `TEST_METHOD(YourTestName){...}`.

         Стандартную сигнатуру функции писать не требуется. Сигнатура создается макросом TEST_METHOD. Макрос создает функцию экземпляра, которая возвращает значение void. Она также создает статическую функцию, которая возвращает сведения о тестовом методе. Эти сведения позволят обозревателю тестов найти этот метод.

    - Тестовые методы группируются в классы с помощью `TEST_CLASS(YourClassName){...}`.

         Во время выполнения тестов создается экземпляр каждого тестового класса. Тестовые методы вызываются в неопределенном порядке. Можно задать особые методы, которые вызываются до и после каждого модуля, класса или метода.

3. Убедитесь в том, что тесты выполняются в обозревателе тестов.

    1. Добавьте код теста:

        ```cpp
        TEST_METHOD(TestMethod1)
        {
            Assert::AreEqual(1,1);
        }
        ```

         Обратите внимание, что класс `Assert` содержит несколько статических методов, которые можно использовать для проверки результатов в тестовых методах.

    2. В меню **Тест** выберите **Запуск** > **Все тесты**.

         Произойдет сборка и запуск теста.

         Появится **обозреватель тестов**.

         Тест отображается в списке **Пройденные тесты**.

         ![Обозреватель модульных тестов с одним пройденным тестом](../test/media/utecpp04.png)

## <a name="create-a-dll-project"></a><a name="create_dll_project"></a> Создание проекта библиотеки DLL

::: moniker range=">=vs-2019"

Ниже показано, как создать проект библиотеки DLL в Visual Studio 2019.

1. Создайте проект на C++ с помощью **мастера создания классических приложений Windows**. В **обозревателе решений** щелкните решение правой кнопкой мыши и выберите команды **Добавить** > **Создать проект**. Задайте **Язык** как C++ и в поле поиска введите "windows". Выберите **Мастер создания классических приложений Windows** в списке результатов.

     В этом пошаговом руководстве проект называется `RootFinder`.

2. Нажмите кнопку **Создать**. В следующем диалоговом окне в разделе **Тип приложения** выберите **Библиотека динамической компоновки (DLL)**, а также установите флажок **Экспортировать символы**.

     Параметр **Экспортировать символы** создает удобный макрос, который можно использовать для объявления экспортированных методов.

     ![Мастер проектов C++, настроенный для DLL и символов экспорта](../test/media/vs-2019/windows-desktop-project-dll.png)

3. Объявите экспортированную функцию в основном *H*-файле.

     ![Новый проект кода DLL и H-файл с макросами API](../test/media/utecpp07.png)

     Оператор объявления `__declspec(dllexport)` делает открытые и защищенные члены класса видимыми вне библиотеки DLL. Для получения дополнительной информации см. [Using dllimport and dllexport in C++ Classes](/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes).

4. В основной *CPP*-файл добавьте минимальное тело функции.

    ```cpp
        // Find the square root of a number.
        double CRootFinder::SquareRoot(double v)
        {
            return 0.0;
        }
    ```

::: moniker-end

::: moniker range="vs-2017"

Ниже показано, как создать проект библиотеки DLL в Visual Studio 2017.

1. Создайте проект на C++ с помощью шаблона **Проект Win32**.

     В этом пошаговом руководстве проект называется `RootFinder`.

2. В мастере приложения Win32 выберите параметры **DLL** и **Экспортировать символы**.

     Параметр **Экспортировать символы** создает удобный макрос, который можно использовать для объявления экспортированных методов.

     ![Мастер проектов C++, настроенный для DLL и символов экспорта](../test/media/utecpp06.png)

3. Объявите экспортированную функцию в основном *H*-файле.

     ![Новый проект кода DLL и H-файл с макросами API](../test/media/utecpp07.png)

     Оператор объявления `__declspec(dllexport)` делает открытые и защищенные члены класса видимыми вне библиотеки DLL. Для получения дополнительной информации см. [Using dllimport and dllexport in C++ Classes](/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes).

4. В основной *CPP*-файл добавьте минимальное тело функции.

    ```cpp
        // Find the square root of a number.
        double CRootFinder::SquareRoot(double v)
        {
            return 0.0;
        }
    ```

::: moniker-end

## <a name="couple-the-test-project-to-the-dll-project"></a><a name="make_functions_visible"></a> Привязка тестового проекта к проекту библиотеки DLL

1. Добавьте проект DLL в ссылки тестового проекта.

   1. Щелкните правой кнопкой мыши узел тестового проекта в **обозревателе решений** и выберите пункты **Добавить** > **Ссылка**.

   2. В диалоговом окне **Добавление ссылки** выберите проект библиотеки DLL и нажмите **Добавить**.

        ![Свойства проекта C++ | Добавление новой ссылки](../test/media/utecpp09.png)

2. В основном *CPP*-файле модульного теста включите *H*-файл кода библиотеки DLL.

   ```cpp
   #include "..\RootFinder\RootFinder.h"
   ```

3. Добавьте простой тест, который использует экспортированную функцию.

   ```cpp
   TEST_METHOD(BasicTest)
   {
      CRootFinder rooter;
      Assert::AreEqual(
         // Expected value:
         0.0,
         // Actual value:
         rooter.SquareRoot(0.0),
         // Tolerance:
         0.01,
        // Message:
        L"Basic test failed",
        // Line number - used if there is no PDB file:
        LINE_INFO());
   }
   ```

4. Создайте решение.

    Новый тест появится в **обозревателе тестов**.

5. В **обозревателе тестов** выберите **Запустить все**.

    ![Обозреватель модульных тестов — базовый тест пройден](../test/media/utecpp10.png)

   Вы настроили тест и проекты кода и подтвердили, что можно выполнять тесты, которые запускают функции из проекта кода. Теперь можно начать писать реальные тесты и код.

## <a name="iteratively-augment-the-tests-and-make-them-pass"></a><a name="iterate"></a> Итеративное расширение тестов и обеспечение их успешного выполнения

1. Добавьте новый тест.

    ```cpp
    TEST_METHOD(RangeTest)
    {
      CRootFinder rooter;
      for (double v = 1e-6; v < 1e6; v = v * 3.2)
      {
        double actual = rooter.SquareRoot(v*v);
        Assert::AreEqual(v, actual, v/1000);
      }
    }
    ```

    > [!TIP]
    > Рекомендуется не изменять пройденные тесты. Вместо этого добавьте новый тест, обновите код так, чтобы тест проходил успешно, а затем добавьте еще один тест и т. д.
    >
    > При изменении пользователями требований отключите тесты, которые больше не являются корректными. Создайте новые тесты и сделайте так, чтобы они работали по одному в инкрементном режиме.

2. Выполните сборку решения, а затем в **обозревателе тестов** щелкните **Запустить все**.

     Новый тест завершится сбоем.

     ![Сбой теста RangeTest](../test/media/ute_cpp_testexplorer_rangetest_fail.png)

    > [!TIP]
    > Убедитесь в том, что каждый тест завершается сбоем, сразу после того, как вы написали его. Это поможет избежать распространенной ошибки, заключающейся в написании теста, который никогда не завершается сбоем.

3. Исправьте код библиотеки DLL, чтобы новый тест проводился успешно:

    ```cpp
    #include <math.h>
    ...
    double CRootFinder::SquareRoot(double v)
    {
      double result = v;
      double diff = v;
      while (diff > result/1000)
      {
        double oldResult = result;
        result = result - (result*result - v)/(2*result);
        diff = abs (oldResult - result);
      }
      return result;
    }
    ```

4. Выполните сборку решения, а затем в **обозревателе тестов** щелкните **Запустить все**.

     Оба теста будут пройдены успешно.

     ![Обозреватель модульных тестов — тест RangeTest пройден](../test/media/utecpp12.png)

    > [!TIP]
    > Разрабатывайте код, добавляя тесты по одному. После каждой итерации проверяйте, все ли тесты завершаются успешно.

## <a name="debug-a-failing-test"></a><a name="debug"></a> Отладка непройденного теста

1. Добавьте еще один тест.

    ```cpp
    #include <stdexcept>
    ...
    // Verify that negative inputs throw an exception.
    TEST_METHOD(NegativeRangeTest)
    {
      wchar_t message[200];
      CRootFinder rooter;
      for (double v = -0.1; v > -3.0; v = v - 0.5)
      {
        try
        {
          // Should raise an exception:
          double result = rooter.SquareRoot(v);

          _swprintf(message, L"No exception for input %g", v);
          Assert::Fail(message, LINE_INFO());
        }
        catch (std::out_of_range ex)
        {
          continue; // Correct exception.
        }
        catch (...)
        {
          _swprintf(message, L"Incorrect exception for %g", v);
          Assert::Fail(message, LINE_INFO());
        }
      }
    }
    ```

2. Выполните сборку решения и щелкните **Запустить все**.

3. Откройте (или дважды щелкните) непройденный тест.

     Ошибочное проверочное утверждение будет выделено. Сообщение об ошибке отображается в области сведений **обозревателя тестов**.

     ![Сбой тестов NegativeRangeTests](../test/media/ute_cpp_testexplorer_negativerangetest_fail.png)

4. Чтобы увидеть, почему тест не был пройден, выполните функцию пошагово.

    1. Установите точку останова в начале функции SquareRoot.

    2. В контекстном меню непройденного теста выберите **Отладить выбранные тесты**.

         Когда выполнение прекратится на точке останова, выполните код по шагам.

5. Вставьте код в функцию, которую вы разрабатываете:

    ```cpp

    #include <stdexcept>
    ...
    double CRootFinder::SquareRoot(double v)
    {
        // Validate parameter:
        if (v < 0.0)
        {
          throw std::out_of_range("Can't do square roots of negatives");
        }

    ```

6. Теперь все тесты проходят успешно.

   ![Все тесты пройдены](../test/media/ute_ult_alltestspass.png)

::: moniker range="vs-2017"

> [!TIP]
> Если у отдельных тестов нет зависимостей, предотвращающих выполнение этих тестов в любом порядке, включите параллельное тестирование с помощью выключателя ![Снимок экрана: выключатель параллельного выполнения тестов на панели инструментов Обозревателя тестов. При выборе этой кнопки тесты будут выполняться параллельно.](../test/media/ute_parallelicon-small.png) на панели инструментов. Это может заметно сократить время, необходимое для выполнения всех тестов.

::: moniker-end

::: moniker range=">=vs-2019"

> [!TIP]
> Если отдельные тесты не имеют зависимостей, предотвращающих запуск этих тестов в любом порядке, включите параллельное тестирование в меню параметров на панели инструментов. Это может заметно сократить время, необходимое для выполнения всех тестов.

::: moniker-end

## <a name="refactor-the-code-without-changing-tests"></a><a name="refactor"></a> Рефакторинг кода без изменения тестов

1. Упростите основное вычисление в функции SquareRoot.

    ```cpp
    // old code:
    //   result = result - (result*result - v)/(2*result);
    // new code:
         result = (result + v/result)/2.0;

    ```

2. Выполните сборку решения и щелкните **Запустить все**, чтобы убедиться в том, что не появилось новых ошибок.

    > [!TIP]
    > Хороший набор модульных тестов дает уверенность в том, что при изменении кода не появилось новых ошибок.
    >
    > Рефакторинг должен осуществляться отдельно от других изменений.

## <a name="next-steps"></a>Дальнейшие действия

- **Изоляция**. Большинство библиотек DLL зависит от других подсистем, например от баз данных и других библиотек DLL. Эти другие компоненты часто разрабатываются параллельно. Чтобы модульное тестирование могло выполняться, пока другие компоненты еще не доступны, нужно заменить макет или выполнить

- **Тесты проверки сборки**. Тесты можно выполнять на сервере сборки рабочей группы через заданные промежутки времени. Это гарантирует то, что во время объединения результатов работы, выполненной разными членами рабочей группы, не появятся новые ошибки.

- **Тесты влияния изменений**. Можно потребовать, чтобы некоторые тесты выполнялись перед тем, как каждый участник рабочей группы вернет код в систему управления версиями. Обычно это подмножество полного набора тестов проверки сборки.

   Можно также требовать минимального уровня покрытия кода.

## <a name="see-also"></a>См. также раздел

- [Модульное тестирование существующих приложений C++ с использованием обозревателя тестов](../test/how-to-use-microsoft-test-framework-for-cpp.md)
- [Использование пространства имен Microsoft.VisualStudio.TestTools.CppUnitTestFramework](how-to-use-microsoft-test-framework-for-cpp.md)
- [Отладка машинного кода](../debugger/debugging-native-code.md)
- [Пошаговое руководство. Создание и использование библиотеки DLL (C++)](/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp)
- [Импорт и экспорт](/cpp/build/importing-and-exporting)
