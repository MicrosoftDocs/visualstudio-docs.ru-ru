---
title: Интеграция Visual Studio (MSBuild)
titleSuffix: ''
description: Узнайте, как Visual Studio может размещать проекты в формате MSBuild, даже если они были созданы с помощью разных средств и настроены во время сборки.
ms.custom: seodec18, SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- MSBuild, reference resolution
- MSBuild, well-known target names
- MSBuild, hosting
- MSBuild, editing project files
- MSBuild, Visual Studio integration
- MSBuild, IntelliSense
- MSBuild, output groups
- MSBuild, in-process compilers
- MSBuild, design-time target execution
ms.assetid: 06cd6d7f-8dc1-4e49-8a72-cc9e331d7bca
author: ghogen
ms.author: ghogen
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: ff8f195b6d77aeab9a01a6f3f6262f4024de1153
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99951658"
---
# <a name="visual-studio-integration-msbuild"></a>Интеграция Visual Studio (MSBuild)

Visual Studio размещает MSBuild для загрузки и сборки управляемых проектов. Поскольку MSBuild отвечает за проект, в Visual Studio можно успешно использовать практически любой проект в формате MSBuild, даже если проект создан с помощью другого инструмента и он участвует в процессе пользовательского построения.

 В данной статье рассматриваются конкретные аспекты размещения MSBuild с помощью Visual Studio, которые необходимо учитывать при настройке проектов и файлов в формате *.targets*, которые требуется загрузить в Visual Studio с последующей сборкой. Это поможет вам обеспечить наличие в настраиваемом проекте таких функций Visual Studio, как IntelliSense и отладка.

 Дополнительные сведения о проектах C++ см. в статье [Файлы проекта](/cpp/build/reference/project-files).

## <a name="project-file-name-extensions"></a>Расширения имени файла проекта

 Файл *MSBuild.exe* распознает любое расширение имени файла проекта, если оно соответствует шаблону *.\*proj*. Однако Visual Studio распознает только подмножество расширений этих имен файлов проекта, определяющее языковую систему проекта, которая будет загружать проект. В Visual Studio нет независящей от языка системы проектов, основанной на использовании MSBuild.

 Например, система проекта C# загружает файлы формата *.csproj*, но Visual Studio не может загружать файлы формата *.xxproj*. Файл проекта для исходных файлов на любом языке должен использовать то же самое расширение, что и файлы проектов Visual Basic или C#, чтобы их можно было загрузить в Visual Studio.

## <a name="well-known-target-names"></a>Известные имена целевых файлов

 При выборе команды **Build** в Visual Studio происходит выполнение целевого файла, который используется в проекте по умолчанию. Этот целевой объект часто называется также `Build`. При выборе команды **Перестроить** или **Очистить** делается попытка выполнить целевой файл с тем же именем в проекте. При выборе команды **Опубликовать** происходит выполнение целевого файла с именем `PublishOnly` в проекте.

## <a name="configurations-and-platforms"></a>Конфигурации и платформы

 Конфигурации представлены в проектах MSBuild свойствами, сгруппированными в элемент `PropertyGroup`, который имеет атрибут `Condition`. Visual Studio анализирует эти условия, чтобы создать отображаемый список конфигураций и платформ проекта. Чтобы можно было успешно получить этот список, соответствующие условия должны иметь формат, аналогичный следующему:

```xml
Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "
Condition=" '$(Configuration)' == 'Release' " 
Condition=" '$(Something)|$(Configuration)|$(SomethingElse)' == 'xxx|Debug|yyy' "
```

 С этой целью Visual Studio проверяет условия в `PropertyGroup`, `ItemGroup`, `Import`, свойствах и элементах объекта.

## <a name="additional-build-actions"></a>Дополнительные действия при сборке

 Visual Studio дает возможность изменить имя типа элемента файла в проекте с помощью свойства **Действие при сборке** в окне **Свойства файла**. В этом меню имена типов элементов **Compile**, **EmbeddedResource**, **Content** и **None** всегда приводятся наряду со всеми другими именами типов элементов, которые уже используются в проекте. Чтобы быть уверенным в том, что в этом меню всегда будут доступны все пользовательские имена типов элементов, эти имена можно добавлять к типу элемента под названием `AvailableItemName`. Например, при добавлении следующих имен к файлу проекта одновременно будет добавлен пользовательский тип **JScript** к этому меню для всех проектов, которые его импортируют:

```xml
<ItemGroup>
    <AvailableItemName Include="JScript"/>
</ItemGroup>
```

> [!NOTE]
> Некоторые имена типов элементов являются особыми для Visual Studio, но их нет в раскрывающемся меню.

## <a name="in-process-compilers"></a>Внутрипроцессные компиляторы

 По возможности Visual Studio будет пытаться использовать внутрипроцессную версию компилятора Visual Basic для повышения производительности. (Неприменимо к C#.) Чтобы при этом была обеспечена правильная работа, должны быть выполнены следующие условия:

- Среди целевых объектов проекта должна быть задача под названием `Vbc` для проектов Visual Basic.

- Для параметра `UseHostCompilerIfAvailable` этой задачи должно быть установлено значение "true".

## <a name="design-time-intellisense"></a>Функция IntelliSense в режиме разработки

 Чтобы получить поддержку IntelliSense в Visual Studio до того, как будет создана конечная сборка, должны выполняться следующие условия.

- Должен существовать целевой объект с именем `Compile`.

- Либо целевой объект `Compile` , либо одна из его зависимостей должны вызывать задачу компилятора для проекта, например `Csc` или `Vbc`.

- Либо целевой объект `Compile` , либо одна из его зависимостей должны инициировать получение компилятором всех необходимых параметров для IntelliSense, особенно всех ссылок.

- Должны выполняться условия, указанные в разделе [Внутрипроцессные компиляторы](#in-process-compilers).

## <a name="build-solutions"></a>Создание решений

 В пределах Visual Studio, управление файлом решения и заказом на построение проекта осуществляется самим Visual Studio. Если построение решения осуществляется с помощью *msbuild.exe* в командной строке, то MSBuild выполняет синтаксический разбор файла решения и дает указание на выполнение построения проекта. В обоих случаях проекты строятся по отдельности в порядке зависимости, и взаимные ссылки между проектами не отслеживаются. В противоположность этому, при построении отдельных проектов с помощью *msbuild.exe* взаимные ссылки между проектами отслеживаются.

 Если построение осуществляется внутри Visual Studio, свойству `$(BuildingInsideVisualStudio)` назначается значение `true`. Это можно использовать при работе с файлами проекта или с файлами в формате *.targets*, если нужно, чтобы построения вели себя по-разному.

## <a name="display-properties-and-items"></a>Отображение свойств и элементов

 Visual Studio распознает имена и значения некоторых свойств. Например, следующее свойство проекта вызывает появление названия **приложения Windows** в поле **Тип приложения** в **конструкторе проектов**.

```xml
<OutputType>WinExe</OutputType>
```

 Значение этого свойства можно изменить в **конструкторе проектов** и сохранить в файле проекта. Если такому свойству присвоено недопустимое значение при вводе вручную, Visual Studio выведет предупреждение при загрузке проекта и заменит недопустимое значение на значение по умолчанию.

 Visual Studio распознает значения по умолчанию для некоторых свойств. Значения этих свойств будут вставляться в файл проекта только в том случае, если они отличаются от значений по умолчанию.

 Свойства, имеющие произвольные имена, не отображаются в Visual Studio. Чтобы изменить произвольно заданное имя в Visual Studio, нужно открыть файл проекта в XML-редакторе и вручную изменить его. Дополнительные сведения см. в разделе [Editing Project Files in Visual Studio](#edit-project-files-in-visual-studio) (Изменение файлов проектов в Visual Studio) ниже.

 Элементы, определенные в проекте с произвольными именами типов элементов, по умолчанию отображаются в **обозревателе решений** в соответствующем узле проекта. Чтобы скрыть элемент, установите значение `Visible` метаданных `false`. Например, указанный ниже элемент будет участвовать в процессе построения, но не будет отображаться в **обозревателе решений**.

```xml
<ItemGroup>
    <IntermediateFile Include="cache.temp">
        <Visible>false</Visible>
    </IntermediateFile>
</ItemGroup>
```

> [!NOTE]
> Метаданные `Visible` игнорируются **обозревателем решений** для проектов C++. Элементы всегда будут отображаться, даже если `Visible` имеет значение false.

 По умолчанию не отображаются элементы, которые объявлены в файлах, импортированных в проект. В **обозревателе решений** никогда не отображаются элементы, созданные в процессе построения.

## <a name="conditions-on-items-and-properties"></a>Условия, накладываемые на элементы и свойства

 В процессе построения полностью учитываются все условия.

 При определении отображаемого значения свойства, те свойства, которые рассматриваются Visual Studio как зависящие от конфигурации, оцениваются не так, как свойства, которые считаются не зависящими от конфигурации. Для свойств, которые считаются зависящими от конфигурации, Visual Studio устанавливает соответствующие свойства `Configuration` и `Platform`, а также дает указание MSBuild еще раз оценить проект. Для свойств, которые считаются не зависящими от конфигурации, определенного способа оценки условий не предусмотрено.

 При решении, следует ли отображать данный элемент в **обозревателе решений**, условные выражения с участием элементов всегда игнорируются.

## <a name="debugging"></a>Отладка

 Чтобы найти и запустить выходную сборку с присоединением отладчика, Visual Studio требуется, чтобы были правильно заданы свойства `OutputPath`, `AssemblyName`, и `OutputType`. Присоединение отладчика невозможно, если в процессе сборки компилятор не создал файл *.pdb*.

## <a name="design-time-target-execution"></a>Выполнение целевых объектов в режиме разработки

 Visual Studio пытается запустить выполнение целевых объектов с определенными именами при загрузке проекта. Эти целевые объекты включают в себя `Compile`, `ResolveAssemblyReferences`, `ResolveCOMReferences`, `GetFrameworkPaths` и `CopyRunEnvironmentFiles`. Visual Studio запускает эти целевые объекты, что позволяет инициализировать компилятор, который обеспечивает функционирование IntelliSense. Возможна также инициализация отладчика и разрешение ссылок, отображаемых в обозревателе решений. Если эти целевые объекты отсутствуют, то загрузка и построение проекта будут выполняться правильно, но работа в Visual Studio в режиме разработки будет иметь функциональные ограничения.

## <a name="edit-project-files-in-visual-studio"></a>Изменение файлов проектов в Visual Studio

 Чтобы изменить непосредственно проект MSBuild, можно открыть файл проекта в XML-редакторе Visual Studio.

#### <a name="to-unload-and-edit-a-project-file-in-visual-studio"></a>Выгрузка и изменение файла проекта в Visual Studio

1. В **обозревателе решений** откройте контекстное меню для своего проекта и выберите **Выгрузить проект**.

     К проекту добавляется пометка **(недоступный)** .

2. В **обозревателе решений** откройте контекстное меню для недоступного проекта и выберите пункт **Изменить\<Project File>** .

     В XML-редакторе Visual Studio открывается файл проекта.

3. Измените, сохраните и закройте файл проекта.

4. В **обозревателе решений** откройте контекстное меню для недоступного проекта и выберите **Перезагрузить проект**.

## <a name="intellisense-and-validation"></a>IntelliSense и проверка

 При использовании XML-редактора для изменения файлов проекта работой IntelliSense и функции проверки управляют файлы схемы MSBuild. Они устанавливаются в кэш схемы, который можно найти в *\<Visual Studio installation directory>\Xml\Schemas\1033\MSBuild*.

 Типы ядра MSBuild определяются в *Microsoft.Build.Core.xsd*, а стандартные типы, используемые Visual Studio, определяются в *Microsoft.Build.CommonTypes.xsd*. Чтобы настроить схемы таким образом, чтобы выполнялась функция IntelliSense и проверка пользовательских имен типов элементов, а также свойств и задач, можно либо изменить *Microsoft.Build.xsd*, либо создать собственную схему, включающую схемы CommonTypes или Core. Если создается собственная схема, необходимо с помощью XML-редактора найти ее, используя окно **Свойства** .

## <a name="edit-loaded-project-files"></a>Правка загруженных файлов проектов

 Visual Studio отправляет в кэш содержимое файлов проектов и файлов, импортированных файлами проекта. Если вы изменяете загруженный файл проекта, Visual Studio автоматически напомнит еще раз загрузить проект, чтобы изменения вступили в силу. Однако, если вы изменяете файл, импортированный загруженным проектом, напоминание о перезагрузке не появится, и необходимо будет вручную выгрузить и еще раз загрузить проект, чтобы изменения вступили в силу.

## <a name="output-groups"></a>Выходные группы

 Имена некоторых целевых объектов, определенных в *Microsoft.Common.targets*, оканчиваются на `OutputGroups` или `OutputGroupDependencies`. Visual Studio вызывает эти целевые объекты, чтобы они получили особые списки выходных данных проекта. Например, целевой объект `SatelliteDllsProjectOutputGroup` создает список всех сопутствующих сборок, которые будут созданы в процессе построения. Эти выходные группы используются, например, такими функциями, как опубликование, развертывание и взаимные ссылки между проектами. Проекты, в которых они не определены, будут загружать и строить их в Visual Studio, но при этом отдельные функции могут работать неправильно.

## <a name="reference-resolution"></a>Разрешение ссылок

 Разрешение ссылок — это процесс использования элементов ссылки, которые хранятся в файле проекта, для определения местоположения реальных сборок. Visual Studio необходимо инициировать разрешение ссылок, чтобы можно было отобразить подробные свойства для каждой ссылки в окне **Свойства**. В следующем списке описаны три типа ссылок и способы их разрешения.

- Ссылки на сборку:

   Система проекта вызывает целевой объект с известным именем `ResolveAssemblyReferences`. Этот целевой объект должен создать элементы с именем типа элемента `ReferencePath`. Каждый из этих элементов должен иметь спецификацию элемента (значение атрибута `Include` элемента), которая содержит полный путь к ссылке. Эти элементы должны иметь все метаданные, полученные от входных элементов, и, кроме того, следующие новые метаданные.

  - `CopyLocal`, указывающие, следует ли скопировать данную сборку в выходную папку, для чего надо присвоить ей значение "true" или "false".

  - `OriginalItemSpec`, содержащую исходную спецификацию элемента ссылки.

  - `ResolvedFrom`, для которого было задано значение "{TargetFrameworkDirectory}", если он был разрешен из каталога .NET Framework.

- Ссылки COM:

   Система проекта вызывает целевой объект с известным именем `ResolveCOMReferences`. Этот целевой объект должен создать элементы с именем типа элемента `ComReferenceWrappers`. Каждый из этих элементов должен иметь спецификацию элемента, которая содержит полный путь к ссылке взаимодействия для ссылки СОМ. Эти элементы должны иметь все метаданные, переданные от входных элементов, и, кроме того, новые метаданные с именем `CopyLocal`, указывающие, следует ли копировать данную сборку в выходную папку, с заданным значением "true" или "false".

- Машинные ссылки

   Система проекта вызывает целевой объект с известным именем `ResolveNativeReferences`. Этот целевой объект должен создать элементы с именем типа элемента `NativeReferenceFile`. Эти элементы должны иметь все метаданные, переданные от входных элементов, и, кроме того, новую порцию метаданных с именем `OriginalItemSpec`, содержащих спецификацию исходных элементов ссылки.

## <a name="performance-shortcuts"></a>Ярлыки производительности

 Если вы используете интегрированную среду разработки Visual Studio для запуска отладки (с помощью клавиши F5 или пункта меню **Отладка** > **Начать отладку**) или сборки проекта (например, **Сборка** > **Собрать решение**), для повышения производительности в процессе сборки будет использоваться быстрая проверка обновлений. В некоторых случаях, когда пользовательские построения создают файлы, которые в свою очередь также участвуют в построениях, быстрая проверка обновлений не может верно определить измененные файлы. В проектах, которые требуют более тщательных проверок обновлений, можно отключить быструю проверку, задав переменную среды `DISABLEFASTUPTODATECHECK=1`. Другой способ — задать ее в качестве свойства MSBuild в проекте или в файле, импортируемом в проект.

 Для обычной сборки в Visual Studio быстрая проверка обновлений не применяется, и сборка проекта будет выполняться, как если бы сборка была вызвана из командной строки.

## <a name="see-also"></a>См. также

- [Практическое руководство. Расширение процесса сборки Visual Studio](../msbuild/how-to-extend-the-visual-studio-build-process.md)
- [Запуск сборки из интегрированной среды разработки](../msbuild/starting-a-build-from-within-the-ide.md)
- [Регистрация расширений платформы .NET Framework](../msbuild/registering-extensions-of-the-dotnet-framework.md)
- [Основные понятия MSBuild](../msbuild/msbuild-concepts.md)
- [Элемент Item (MSBuild)](../msbuild/item-element-msbuild.md)
- [Элемент Property (MSBuild)](../msbuild/property-element-msbuild.md)
- [Элемент Target (MSBuild)](../msbuild/target-element-msbuild.md)
- [Задача Csc](../msbuild/csc-task.md)
- [Задача Vbc](../msbuild/vbc-task.md)
